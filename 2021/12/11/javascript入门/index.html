<!DOCTYPE html><html lang="cn_Zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>javascript入门 | CodeFish</title><meta name="keywords" content="javaScript"><meta name="author" content="CodeFish"><meta name="copyright" content="CodeFish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="撸js的第一遍，持续不断深入的学习一门语言应当坚持下去，每一回学习都会有不一样的体会。 javascript介绍JavaScript 是脚本语言（作为web的JavaScript 是一种函数优先轻量级的编程语言。 JavaScript 是可插入 HTML 页面的编程代码。 JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。 JavaScript 基于原型编程，多范式的动态脚本">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript入门">
<meta property="og:url" content="https://codefish.cc/2021/12/11/javascript%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="CodeFish">
<meta property="og:description" content="撸js的第一遍，持续不断深入的学习一门语言应当坚持下去，每一回学习都会有不一样的体会。 javascript介绍JavaScript 是脚本语言（作为web的JavaScript 是一种函数优先轻量级的编程语言。 JavaScript 是可插入 HTML 页面的编程代码。 JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。 JavaScript 基于原型编程，多范式的动态脚本">
<meta property="og:locale" content="cn_ZH">
<meta property="og:image" content="https://codefish.cc/img/2.jpg">
<meta property="article:published_time" content="2021-12-11T16:13:52.000Z">
<meta property="article:modified_time" content="2025-01-08T14:31:13.235Z">
<meta property="article:author" content="CodeFish">
<meta property="article:tag" content="javaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://codefish.cc/img/2.jpg"><link rel="shortcut icon" href="/hexo/img/favicon.ico"><link rel="canonical" href="https://codefish.cc/2021/12/11/javascript%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/hexo/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/hexo/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'javascript入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-08 14:31:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/hexo/loading" data-lazy-src="/hexo/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/hexo/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a></div><div class="data-item"><a href="/hexo/tags/"><div class="headline">Tags</div><div class="length-num">38</div></a></div><div class="data-item"><a href="/hexo/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/play/"><i class="fa-fw fsa fa-child"></i><span> 娱乐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/hexo/img/2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/hexo/">CodeFish</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/play/"><i class="fa-fw fsa fa-child"></i><span> 娱乐</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">javascript入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">Updated</span><time datetime="2025-01-08T14:31:13.235Z" title="Updated 2025-01-08 14:31:13">2025-01-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/hexo/categories/js/">js</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="javascript入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/hexo/2021/12/11/javascript%E5%85%A5%E9%97%A8/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/hexo/2021/12/11/javascript%E5%85%A5%E9%97%A8/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>撸js的第一遍，持续不断深入的学习一门语言应当坚持下去，每一回学习都会有不一样的体会。</p>
<h1 id="javascript介绍"><a href="#javascript介绍" class="headerlink" title="javascript介绍"></a>javascript介绍</h1><h2 id="JavaScript-是脚本语言（作为web的"><a href="#JavaScript-是脚本语言（作为web的" class="headerlink" title="JavaScript 是脚本语言（作为web的"></a>JavaScript 是脚本语言（作为web的</h2><p>JavaScript 是一种函数优先轻量级的编程语言。</p>
<p>JavaScript 是可插入 HTML 页面的编程代码。</p>
<p>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</p>
<p>JavaScript 基于原型编程，多范式的动态脚本语言，支持面向对象，命令式，声明式，函数式编程范式，解释性或即时编译型的编程语言</p>
<p>网景 –&gt;欧洲计算机协会 –&gt;ECMAScript(ES)</p>
<p>Javascipt 核心语法</p>
<p>核心语法（ESMAscript） DOM（W3C) BOM(网景)</p>
<p>ES1           …         ES3       …          ES5</p>
<p>ES4（去掉改动大的语法,和谐会议）</p>
<p>ES6 2015年   当年争议的话题</p>
<p>ES7 -ES11 一年一更新 2016-2020 ES6之后统称ES6</p>
<p>语法糖 ：ES6 写代码运行更快</p>
<h2 id="JavaScript作用"><a href="#JavaScript作用" class="headerlink" title="JavaScript作用"></a>JavaScript作用</h2><p>网页开发</p>
<p>JS包含三个部分的内容（在浏览器端</p>
<ul>
<li>​        核心语法<ul>
<li>变量</li>
<li>流程控制</li>
<li>循环</li>
<li>数据类型</li>
</ul>
</li>
<li>​        BOM (网景)<ul>
<li>浏览器对象模型 borwer object model</li>
</ul>
</li>
<li>​        DOM （W3C)<ul>
<li>文档对象模型，和网页相关  document object model</li>
</ul>
</li>
</ul>
<h2 id="宿主环境"><a href="#宿主环境" class="headerlink" title="宿主环境"></a>宿主环境</h2><p>定义：JS运行的环境就叫宿主环境</p>
<ul>
<li>​    node</li>
<li>浏览器</li>
</ul>
<p>作用：</p>
<ol>
<li><p>交互效果</p>
</li>
<li><p>收集数据</p>
</li>
</ol>
<h2 id="JS-的准备语法"><a href="#JS-的准备语法" class="headerlink" title="JS 的准备语法"></a>JS 的准备语法</h2><ul>
<li><p>如何编写JS文件</p>
<ol>
<li>将JS嵌入到网页当中</li>
<li>将JS文件引入到文档中</li>
</ol>
</li>
<li><p>Script标签的位置</p>
<ol>
<li><p>可以放在网页任何位置（放在html标签外面，页面最上面，浏览器自动把他放在head中，但是文档声明头消失）–&gt; 解析时，浏览器会采用降价处理。h5-h4  【如果文档没有写文档声明头】 理论上可以放任何位置，唯独不建议放在文档声明头上面</p>
</li>
<li><p>建议的位置 </html> 之后，浏览器会默认将其移动到<body>之中。放在<body/>和</html>之间</p>
<ul>
<li>js操作标签，页面元素先渲染出页面，即该标签先加载成功，script才开始获取元素。</li>
<li>标准文档流的解析顺序</li>
<li><strong>操作input标签 首要前提是 input要加载成功</strong></li>
</ul>
</li>
<li><p>独立的Js文件引入</p>
<ul>
<li><script src=''></script>
</li>
<li><p>通过script标签配合src配合</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>打印</p>
<ul>
<li><p>在JS代码调试的时候，经常需要使用到console.log()</p>
<ol>
<li><p>console 是一个对象，里面有很多函数可以来帮助我们来开发，最常用的是console.log</p>
</li>
<li><p>弹窗</p>
<ol>
<li>alert</li>
<li>prompt 比confirm多一个input框框</li>
<li>confirm 比alert多一个取消</li>
</ol>
<ul>
<li>​     alert（） 加括号为一个函数</li>
</ul>
</li>
<li><p>语句和表达式</p>
<ol>
<li>语句<ul>
<li>有多个部分组成，不一定有结果</li>
<li>eg：console.log()</li>
<li><strong>语句都是从右向左看</strong></li>
</ul>
</li>
<li>表达式<ul>
<li>凡是强调有结果</li>
</ul>
</li>
</ol>
</li>
<li><p>语句结束符</p>
<ol>
<li>在语句的最后，最后写上一个语句的结束符号</li>
</ol>
</li>
</ol>
<h3 id="文档入口函数"><a href="#文档入口函数" class="headerlink" title="文档入口函数"></a>文档入口函数</h3><p>window.onload &#x3D; function(){</p>
<p>​    在函数当中的代码会在页面的最后执行</p>
<p>}</p>
<p>放在head中不会出错</p>
<p><strong>如果页面有部分图片或资源加载不出来，则js会一直等待起加载，导致关键js交互无效果。</strong></p>
<p>window &gt; document</p>
<h4 id="如果页面有多个入口函数"><a href="#如果页面有多个入口函数" class="headerlink" title="如果页面有多个入口函数"></a>如果页面有多个入口函数</h4><p><strong>后面加载的覆盖前面的</strong></p>
<h4 id="onclick同理"><a href="#onclick同理" class="headerlink" title="onclick同理"></a>onclick同理</h4><p><strong>外部js也需要文本入口函数</strong>,位置放在</html>之后</p>
<p>如果是工具类的js文件，（不会主动的获取js中的某个），则可以写在head文件中，如果是自己需要操作标签元素的，最好写在body之后</p>
<p>PS：script  和   script src 不能混用</p>
</li>
</ul>
</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>​    定义：临时存储数据的容器</p>
<ol>
<li><p>​    如何创建一个变量</p>
<p>​    var 变量名 &#x3D; 值</p>
<ul>
<li>小驼峰命名</li>
<li>console.log() 如果打印的是一个变量，不需要加引号</li>
<li>underfined当变量声明未赋值的时候，则为未定义</li>
</ul>
</li>
<li><p>变量名的命名规则</p>
<ul>
<li><p>字母数字下划线，<strong>字符</strong>，命名</p>
</li>
<li><p>数字不能是首字母  -&gt; <strong>可以下划线开头</strong></p>
<ul>
<li>尽量词能表达意</li>
</ul>
</li>
<li><p>不能使用关键字</p>
<p><strong>上面也是标识符命名规则</strong></p>
</li>
<li><p>声明和初始化</p>
<ul>
<li>通过关键字创建一个变量即为变量声明，给变量<strong>第一次赋值</strong>既是初始化</li>
<li>控制台凡是出现<strong>蓝色</strong>的都是数字</li>
<li>控制台凡是出现<strong>黑色</strong>的都是文字</li>
<li><strong>程序从右向左看</strong></li>
<li>修改值的过程，叫<strong>重新赋值</strong> x &#x3D; a</li>
<li>重新声明赋值初始化 var x &#x3D; ‘hello,x’  旧的值被回收</li>
</ul>
</li>
</ul>
</li>
<li><p>变量提升</p>
<ul>
<li>浏览器的js解析引擎，在真正执行代码的时候，会进行预解析</li>
<li>变量声明提升 声明不赋值 underfinded</li>
<li>把所以的声明语句提升到作用域的最顶端<ul>
<li>如若未声明直接使用，则报错</li>
</ul>
</li>
<li>原因：在正式执行之前，会对其进行预解析</li>
<li><strong>提升到当前作用域的最顶端</strong></li>
</ul>
<p>ps：使用js属性对应的方法<strong>length属性</strong>，获取字符串的长度</p>
<p>​    获取字符串长度</p>
<h4 id="js是一门弱类型语言"><a href="#js是一门弱类型语言" class="headerlink" title="js是一门弱类型语言"></a>js是一门弱类型语言</h4><p>var a (string int)  强类型</p>
<p>变量可以根据数据的需要随时更换类型（变量本身没有类型，赋的值是上面类型就是上面类型）</p>
</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>基本数据类型</strong></p>
<ul>
<li>string</li>
<li>number</li>
<li>Boolean</li>
<li>underfinded</li>
<li>null</li>
</ul>
<p><strong>引用数据类型</strong></p>
<p>细化：object </p>
<ul>
<li>​    array</li>
<li>​    function</li>
<li>​     object</li>
</ul>
<p><strong>栈</strong> <strong>堆</strong></p>
<p>基本（基础）数据类型，主要存储在栈</p>
<p>引用数据在栈区存放内存地址，堆里存放数据的值</p>
<p><strong>PS：</strong><strong><strong>当一个引用数据类型赋值给一个变量时，这个变量存储的是简单的内存地址</strong></strong></p>
<h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><p>定义:在代码中如果想要存储文字</p>
<p>‘’ “” 没有区别，<strong>推荐使用单引号</strong></p>
<ul>
<li><p>html标签属性都是双引号，为了区分。一致性不混用</p>
</li>
<li><p>结合实际情况，<strong>单引号里嵌套双引号</strong>   …说:””.</p>
<ul>
<li>存在问题 …说:’’</li>
<li>单引号里使用双引号，<strong>双引号里面使用单引号</strong></li>
</ul>
</li>
</ul>
<h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>var s1 &#x3D; ‘鲁迅先生说:’ + ‘’</p>
<p>相当于拼接字符串</p>
<h4 id="创建字符串-–-通过构造函数"><a href="#创建字符串-–-通过构造函数" class="headerlink" title="创建字符串   –   通过构造函数"></a>创建字符串   –   通过构造函数</h4><p>var s &#x3D; new String(‘’)</p>
<p>var s1 &#x3D; ‘’    直接量，相当于js给我们提供的一种用来创建字符串类型的快捷方式</p>
<p>在Js里，除了null和underfinded都可以用构造函数创建出来</p>
<p>不管里面是什么类型，只要外面加了引号，就会变成字符串类型</p>
<p><strong>创建字符串的方式</strong></p>
<ul>
<li>‘’</li>
<li>“”</li>
<li>构造函数</li>
</ul>
<p>通过’+’拼接字符串</p>
<p><strong>注意：</strong>****</p>
<ul>
<li>保证代码中使用统一的符号</li>
<li>单双不能单独嵌套使用</li>
</ul>
<p>可以通过length属性来获取字符串的长度</p>
<p><strong>ps 除了null和underfinded其他都是对象</strong></p>
<p><strong>PS1 任何数据类型都可以通过构造函数的形式创造出来</strong></p>
<p><strong>构造函数创建出来的数据，是一个object</strong></p>
<p>&#x2F;&#x2F;对象 console是一个对象，log是console身上的方法</p>
<p>length(在字符串中) 。2+</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p> 在js中，number远远比其他语言当中的number简单</p>
<p>无整数，本质上都是小数 0.2+0.3 ！&#x3D;&#x3D; 0.5</p>
<p><strong>toFixed</strong> &#x2F;&#x2F;去除小数，返回整数位置，数字类型变为string（文本</p>
<h2 id="布尔-boolean"><a href="#布尔-boolean" class="headerlink" title="布尔 boolean"></a>布尔 boolean</h2><h5 id="真和假-false-和true"><a href="#真和假-false-和true" class="headerlink" title="真和假 false 和true"></a>真和假 false 和true</h5><p>ps：表示一个判断的结果</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>ps：一般用来表示一个对象的空值</p>
<h2 id="Underfinded"><a href="#Underfinded" class="headerlink" title="Underfinded"></a>Underfinded</h2><p>ps：一般表示变量没有初始化</p>
<ul>
<li>先声明一个变量，在某一行未来要使用某个变量，<strong>建议给声明的变量设置一个初始值</strong></li>
</ul>
<h2 id="基础数据类型之间的类型转换"><a href="#基础数据类型之间的类型转换" class="headerlink" title="基础数据类型之间的类型转换"></a><strong>基础数据类型之间的类型转换</strong></h2><p>ps：把一个类型的数据转换为另一个数据类型</p>
<ul>
<li>自动类型数据转换</li>
<li>强制数据类型转换</li>
</ul>
<h4 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h4><p>NaN是JS里一个特殊值，和任何都不相等，连同自己</p>
<p>​        typeof（）<strong>帮助查看数据类型</strong></p>
<ul>
<li><p>​    String（）</p>
<ul>
<li><p>ps：相当于将原数据外面加一个引号</p>
</li>
<li><p>负值转换也是负值的字符串</p>
</li>
</ul>
</li>
<li><p>​    Number（）</p>
<ul>
<li>**ps ** 当其他数据类型的数据不能转换为有效的数字类型时，则被转换为NaN</li>
<li>Number(‘’)   或空串  -&gt;  0</li>
<li>‘hello world’ -&gt; <strong>NaN</strong></li>
<li>‘100 ‘ -&gt; 100</li>
<li>‘a1’ -&gt; <strong>NaN</strong></li>
<li>boolean true -&gt; 1</li>
<li>boolean false -&gt; 0</li>
</ul>
</li>
<li><p>​    Boolean（）</p>
<ul>
<li>ps:把其他数据类型转换为boolean</li>
<li><strong>‘’ 空串 -&gt; false</strong></li>
<li><strong>0 -&gt; false</strong></li>
<li>1 -1 -&gt; true</li>
<li><strong>null -&gt; false</strong></li>
<li><strong>underfinded -&gt; false</strong></li>
<li><strong>NaN -&gt; false</strong></li>
<li><strong>false -&gt; false</strong></li>
<li>boolean(null underfinded) -&gt; false</li>
</ul>
</li>
</ul>
<p><strong>适用于number</strong></p>
<ul>
<li>parseInt（）<ul>
<li>ps：强制转换为整数</li>
<li>还适用于将其他数据类型转换为整型</li>
<li>s1 &#x3D; ‘abc123’ -&gt; NaN</li>
<li>s2 &#x3D;’123abc’ -&gt; 123</li>
</ul>
</li>
<li>parseFloat() 将其他数据类型转换成float<ul>
<li>1.32a -&gt; 1.32</li>
<li>‘1a’ -&gt; 1</li>
</ul>
</li>
</ul>
<p><strong>typeof</strong></p>
<ol>
<li>null object</li>
<li>underfnded underfinded</li>
</ol>
<ul>
<li>underfinded派生于null</li>
</ul>
<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><ul>
<li>数字 + 字符串 –&gt; 转换为字符串</li>
<li>数字 - ‘数字字符串’  -&gt; 字符串转换成数字</li>
<li>数字 *  ‘数字字符串’ -&gt; 字符串转换成数字</li>
<li>数字 &#x2F;    ‘数字字符串’ -&gt; 字符串转化成数字</li>
<li>Boolean和数字计算时（+-*&#x2F;），Boolean转换为数字</li>
<li>字符串数字 + 布尔 -&gt;二者变换成字符串</li>
<li>字符串数字 -*&#x2F; 布尔  -&gt; 都会变成数字</li>
<li>字符串 + 布尔 -&gt; 二者都变成字符串</li>
<li>字符串 -*&#x2F; 布尔 二者都变成Number</li>
<li>任何值和NaN计算，结果都是NaN</li>
<li>null 和 underfinded 都是 NaN</li>
<li><strong>尽可能写程序时，把不可控的因素变成可控的，例如类型转换</strong>**</li>
<li>自动类型转换调用的方法就是上面提到的三个方法，Number，String，Boolean</li>
</ul>
<p>ps：将数字以最快转换为空串 +’’</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><h4 id="除数不能为0-infinity"><a href="#除数不能为0-infinity" class="headerlink" title="除数不能为0 infinity"></a>除数不能为0 infinity</h4><h4 id="JS操作html和css修改标签样式、"><a href="#JS操作html和css修改标签样式、" class="headerlink" title="JS操作html和css修改标签样式、"></a>JS操作html和css修改标签样式、</h4><ol>
<li><p>找到当前元素btna &#x3D;  getElementById(‘btn’)</p>
</li>
<li><p>触发事件 (确定事件三要素)</p>
<ul>
<li>事件：用户在浏览器中的一切动作<ul>
<li>鼠标事件，键盘事件，文档事件</li>
</ul>
</li>
<li>事件三要素 <ul>
<li>事件源</li>
<li>事件</li>
<li>事件处理函数</li>
</ul>
</li>
</ul>
<p>btna.onclick &#x3D; function(){</p>
<p>&#96;    &#x2F;&#x2F;处理的事情</p>
<p>​    alert(‘…’)</p>
<p>}</p>
<ul>
<li><strong>事件处理函数有无不影响事件的发生</strong></li>
</ul>
</li>
</ol>
<p><strong>eg</strong></p>
<ul>
<li>获取输入框中的内容<ul>
<li>element.value</li>
</ul>
</li>
</ul>
<h3 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h3><ul>
<li>加</li>
<li>减</li>
<li>乘</li>
<li>除</li>
<li>求模&#x2F;取余 %</li>
<li>++ – %&#x3D; </li>
<li>&#x3D; !&#x3D; 值不等</li>
<li>&#x3D;&#x3D; 值相等  !&#x3D;&#x3D; 值和类型其一(或）不等</li>
<li>&#x3D;&#x3D;&#x3D; 值和类型都相等</li>
<li>&lt; &gt; &lt;&#x3D; &gt;&#x3D;</li>
<li>&amp;&amp; || !<ul>
<li>短路问题</li>
</ul>
</li>
</ul>
<p>console.log(new Boolean(false))<br>Boolean {false}</p>
<p>typeof(new Boolean(false))</p>
<p>object</p>
<p><strong><code>typeof(null)</code></strong><br><strong><code>&#39;object&#39;</code></strong><br><strong><code>typeof(underfinded)</code></strong><br><strong><code>&#39;undefined&#39;</code></strong><br><strong><code>typeof(NaN)</code></strong><br><strong>‘number’</strong></p>
<p><strong>取反 先转换成布尔值再取反</strong></p>
<p><strong>取反 取反 !!x  &#x3D; Boolean(x)</strong></p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>ps:&amp;&amp; 和 || 存在短路问题</p>
<p>​    惰性面</p>
<ol>
<li>&amp;&amp;</li>
<li>||</li>
</ol>
<p><strong>()改变运算符的优先级，里面存放都是表达式。</strong></p>
<h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p>栈区大小确定  -&gt; 基本数据类型不变 var b &#x3D; true</p>
<p>堆区随需要可以扩容</p>
<h3 id="JS-严格区分大小写"><a href="#JS-严格区分大小写" class="headerlink" title="JS 严格区分大小写"></a>JS 严格区分大小写</h3><h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p>​    是一个数据类型，在Null这个类型只有一个值，就是null.</p>
<ul>
<li>​    <strong>表示一个空值，给空对象赋值</strong></li>
</ul>
<h3 id="Underfinded-1"><a href="#Underfinded-1" class="headerlink" title="Underfinded"></a>Underfinded</h3><p>​    是一个数据类型，在underfinded这个类型只有一个值，就是underfinded</p>
<p>​    派生于Null</p>
<ul>
<li>​        <strong>null &#x3D;&#x3D; underfinded</strong></li>
</ul>
<h2 id="流程控制和循环"><a href="#流程控制和循环" class="headerlink" title="流程控制和循环"></a>流程控制和循环</h2><ul>
<li>if<ul>
<li>如果条件不是Boolean，则会强制转换为Boolean</li>
</ul>
</li>
<li>if else<ul>
<li>else if</li>
<li>ps:嵌套过多降低代码可读性</li>
</ul>
</li>
<li>switch</li>
<li>三元</li>
</ul>
<p><strong>Dom操作</strong> -&gt; 看重执行顺序</p>
<h4 id="swith"><a href="#swith" class="headerlink" title="swith"></a>swith</h4><p>switch(条件)</p>
<p>{</p>
<p>case’张三’:;</p>
<p>case’张四’:;</p>
<p>}</p>
<p><strong>多个case共用一个代码块</strong></p>
<p>case:    case 2:   … case n: 语句 ;  break</p>
<p>break continue</p>
<h4 id="switch展示结果不确定，switch保存数据"><a href="#switch展示结果不确定，switch保存数据" class="headerlink" title="switch展示结果不确定，switch保存数据"></a>switch展示结果不确定，switch保存数据</h4><p><img src= "/hexo/loading" data-lazy-src="/hexo/%E5%AD%A6%E4%B9%A0/mdimages/image-20211130135105212.png" alt="image-20211130135105212"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="title function_">fuction</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> input_value = input.<span class="property">value</span></span><br><span class="line">    <span class="keyword">if</span>(input_value.<span class="property">length</span> === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;输入不能为空&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>trim() 去除两端的空格 – &gt; 字符串方法</strong></p>
<p><strong>如果是一个长空串，则处理为空串</strong></p>
<p><strong>isNaN  判断是否是NaN</strong></p>
<p><strong>math.random()</strong></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li>while</li>
<li>do..while</li>
<li>for</li>
</ul>
<p>random() 随机数函数</p>
<p>return 函数使用</p>
<p>continue</p>
<p>break</p>
<p><strong>var lis &#x3D; list.children</strong></p>
<p><strong>获取list的children</strong></p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>流程控制就是来控制我们的代码按照什么结构顺序来执行。</p>
<p>流程控制主要有以下三种结构，分别是：</p>
<p>（1）顺序结构</p>
<p>（2）分支结构</p>
<p>（3）循环结构</p>
<p>顺序流程控制<br>顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行。<br>分支流程控制<br>由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码，从而得到不同的结果。</p>
<h3 id="1-if分支语句"><a href="#1-if分支语句" class="headerlink" title="1.if分支语句"></a>1.if分支语句</h3><p>&#x2F;&#x2F;if分支语句的语法结构如下：<br>&#x2F;&#x2F;条件成立执行代码，否则什么也不做<br>if(条件表达式){<br>    &#x2F;&#x2F;条件成立执行的代码语句<br>}</p>
<h3 id="2-if-else双分支语句"><a href="#2-if-else双分支语句" class="headerlink" title="2.if else双分支语句"></a>2.if else双分支语句</h3><p>&#x2F;&#x2F;if else双分支语句的语法格式如下：<br>&#x2F;&#x2F;条件成立执行if里面的代码，否则执行else里面的代码<br>if(条件表达式){<br>  &#x2F;&#x2F;条件成立执行的代码<br>}else{<br>  &#x2F;&#x2F;条件不成立执行的代码<br>}</p>
<h3 id="3-if-else-if多分支语句"><a href="#3-if-else-if多分支语句" class="headerlink" title="3.if else if多分支语句"></a>3.if else if多分支语句</h3><p>&#x2F;&#x2F;if else if多分支语句的语法格式如下：<br>&#x2F;&#x2F;适合检查多重条件<br>if(条件表达式1){<br>  语句1;<br>}else if(条件表达式2){<br>  语句2;<br>}else if(条件表达式3){<br>  语句3;<br>  …<br>}else{<br>  &#x2F;&#x2F;上述条件都不成立时执行此代码<br>}</p>
<h3 id="4-三元表达式"><a href="#4-三元表达式" class="headerlink" title="4.三元表达式"></a>4.三元表达式</h3><p>由三元运算符组成的式子就称为三元表达式（因为三元表达式也是表达式，所以会有返回结果）。<br>&#x2F;&#x2F;三元不等式的语法机构如下：<br>条件表达式 ？ 表达式1 ： 表达式2;<br>&#x2F;&#x2F;如果条件表达式的结果为真，则返回表达式1点值；而如果条件表达式的结果为假，则返回表达式2的值。</p>
<h3 id="5-switch语句"><a href="#5-switch语句" class="headerlink" title="5.switch语句"></a>5.switch语句</h3><p>switch语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用switch。<br>&#x2F;&#x2F;switch语句的语法格式如下：<br>switch(表达式){<br>  case value1:<br>    &#x2F;&#x2F;表达式等于value1时要执行的代码<br>    break;<br>  case value2:<br>    &#x2F;&#x2F;表达式等于value2时要执行的代码<br>    break;<br>  default:<br>    &#x2F;&#x2F;表达式不等于任何一个value值时要执行的代码<br>}</p>
<p>switch语句中的条件表达式我们经常写成变量的形式。<br>表达式的值与value的值相匹配时，要求值和数据类型一致才算匹配成功。<br>如果当前case里面没有break，则不回退出switch语句，而是继续执行下一个case，直到遇到break或执行default语句才退出switch语句。</p>
<h3 id="6-switch语句和if-else-if语句的区别"><a href="#6-switch语句和if-else-if语句的区别" class="headerlink" title="6.switch语句和if else if语句的区别"></a>6.switch语句和if else if语句的区别</h3><p>一般情况下，它们两个语句可以相互替换。<br>switch…case语句通常处理case为比较确定值的情况，而if…else…语句更加灵活，常用于范围判断（大于、等于某个范围）。<br>switch语句进行条件判断后直接执行到程序的条件语句，而if…else…语句有几种条件，就得判断几次（从上到下依次判断）。<br>当分支比较少时，if…else…语句的执行效率比switch语句更高。<br>当分支比较多时，switch语句的执行效率比if…else…语句更高，结构也更清晰。</p>
<h2 id="循环流程控制"><a href="#循环流程控制" class="headerlink" title="循环流程控制"></a>循环流程控制</h2><p>目的：重复执行某些代码。</p>
<p>在JS中，主要有以下三种类型的循环语句：</p>
<p>（1）for循环</p>
<p>（2）while循环</p>
<p>（3）do…while循环</p>
<h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1.for循环"></a>1.for循环</h3><p>在程序中，一组被重复执行的语句被称为循环体，而能否继续重复执行，则取决于循环的终止条件。<br>循环语句是指由循环体和循环的终止条件造成的句子。<br>for循环主要用于把某些代码循环若干次，通常跟计数有关系。<br>&#x2F;&#x2F;for循环的语法结构如下：<br>for(初始化变量;条件表达式;操作表达式){<br>  &#x2F;&#x2F;循环体<br>}<br>&#x2F;&#x2F;初始化变量：其实就是用var声明一个普通的变量，并且这个变量通常是作为计数器使用。<br>&#x2F;&#x2F;条件表达式：用来决定每一次循环是否继续执行，也就是循环的终止条件。<br>&#x2F;&#x2F;操作表达式：每次循环最后执行的代码，经常用于更新计数器（递增或递减）。</p>
<p>for循环可以重复执行相同的代码。<br>因为有计数器的存在，使用for循环可以重复执行不同代码。<br>for(var i &#x3D; 1; i &lt;&#x3D; 31; i++){<br>  console.log(‘今天是5月’+i+’日了！’);</p>
<p>因为有计数器的存在，使用for循环可以重复执行某些操作，比如：算数运算。<br>var sum &#x3D; 0;<br>for(var i &#x3D; 1; i &lt;&#x3D; 10; i++){<br>  sum+&#x3D;i;<br>}<br>console.log(sum);</p>
<p>循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构。像在一个for循环语句中， 再嵌套一个for循环，我们就称之为双重for循环。<br>for(var i &#x3D; 1; i &lt;&#x3D; 3; i++){<br>  console.log(‘这是第’+i+’次外层循环’);<br>  for(var j &#x3D; 1; j &lt;&#x3D; 3; j++){<br>    console.log(‘这是第’+i+’次里层循环’);<br>  }<br>}</p>
<h3 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h3><p>while语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环。<br>&#x2F;&#x2F;while语句的语法结构如下：<br>while(条件表达式){<br>  &#x2F;&#x2F;循环体代码<br>}</p>
<h3 id="3-do-while循环"><a href="#3-do-while循环" class="headerlink" title="3.do while循环"></a>3.do while循环</h3><p>do…while语句其实是while语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环。（do while循环语句至少执行一次循环体代码）<br>&#x2F;&#x2F;do while语句的语法结构如下：<br>do{<br>  &#x2F;&#x2F;循环体代码<br>}while(条件表达式);</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><p>三种循环在很多情况下都是可以相互替代使用的。<br>对于计数，三者的使用基本相同，但是更常用的还是for循环。<br>对于更复杂的判断条件，可以使用while和do while语句。</p>
<p><strong>while语句是先判断后执行；而do while是先执行一次后判断执行。</strong></p>
<h5 id="do-while-至少执行一次，while，for最少执行0次"><a href="#do-while-至少执行一次，while，for最少执行0次" class="headerlink" title="do while 至少执行一次，while，for最少执行0次"></a>do while 至少执行一次，while，for最少执行0次</h5><p>continue和break</p>
<h4 id="1-continue关键字"><a href="#1-continue关键字" class="headerlink" title="1.continue关键字"></a>1.continue关键字</h4><p>continue关键字用于立即跳出本次循环，继续下一次循环（本次循环体中continue之后的代码就会少执行一次）。<br>var sum &#x3D; 0;<br>for(var i &#x3D; 1; i &lt;&#x3D; 100; i++){<br>  if(i % 7 &#x3D;&#x3D; 0){<br>    continue;<br>  }<br>  sum+&#x3D;i;<br>}<br>console.log(sum);</p>
<h4 id="2-break关键字"><a href="#2-break关键字" class="headerlink" title="2.break关键字"></a>2.break关键字</h4><p>break关键字用于立即跳出整个循环。<br>for(var i &#x3D; 1; i &lt;&#x3D;5; i++){<br>  if(i &#x3D;&#x3D; 3){<br>    break;<br>  }<br>  console.log(‘这是第’+i+’个数！’);<br>}</p>
<h3 id="…className-x3D-‘’-去掉类名"><a href="#…className-x3D-‘’-去掉类名" class="headerlink" title="…className &#x3D; ‘’ 去掉类名"></a>…className &#x3D; ‘’ 去掉类名</h3><p>data-XXX &#x3D;’’  html5自定义类型存数据</p>
<p>getAttribute</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h4><ol>
<li>一系列的值</li>
<li>希望快速存储和取数据的时候</li>
</ol>
<ul>
<li><p>在向数据中插入元素的时候，如果索引值不连续，就会形成空位</p>
</li>
<li><p>对于索引值不连续的数组，称之为稀疏数组</p>
</li>
<li><p>length 获取数组元素</p>
</li>
<li><p>length比索引值大1</p>
</li>
<li><p>PS ：如果length设置比其大，则后都是空位</p>
<ul>
<li>如果length设置比索引值小，则从后面清楚</li>
<li>快速清空数组，arr.length &#x3D; 0</li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>length失效****一</strong></p>
<ul>
<li><p>数组添加元素key不为数组，则不会被计算</p>
</li>
<li><p>arr[‘name’] &#x3D; ‘哈哈哈’ 计算数组长度的时候，当前元素失效</p>
</li>
<li><p>长度 &#x3D;&#x3D; 任然是最大索引值加1  只计算数字索引</p>
</li>
</ul>
</li>
<li><p><strong>length失效****一</strong></p>
<ul>
<li>arr[100] &#x3D; ‘hhh’&#x2F;</li>
<li>console.log(arr.length) &#x2F;&#x2F;101</li>
</ul>
</li>
</ol>
<p>for可以以索引取字符串的值</p>
<p><strong>字符串后面用方括号</strong></p>
<p><strong>对象.属性（方法</strong></p>
<p>数组. 后面只能是一个符合</p>
<p><strong>对象[属性]  允许使用方括号解析属性</strong></p>
<p><strong>obj 对象 有一个 hello 属性</strong></p>
<p><strong>var a &#x3D; ‘hello’</strong></p>
<p><strong>obj[a] –&gt; obj[‘hello]   js引擎将a解析为一个变量</strong></p>
<p><strong>–数组是一种特殊的对象 key-value</strong></p>
<p><strong>–特殊类型（凡是对象key都是字符串，）</strong></p>
<ul>
<li>​    <strong>数组的key看上去是一个number，实际上会给他转换为string</strong></li>
<li><strong>一切皆对象，除了null和underfinded很多数据类型都对象的特点，有属性和方法，以key-value为结构，key的类型永远是字符串，调用属性的时候可以用点可以用方括号</strong></li>
<li>数组的key可以为字符串</li>
</ul>
<h3 id="空位"><a href="#空位" class="headerlink" title="空位"></a>空位</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产生5个数组空位的数组</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="title class_">Array</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上3</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [,<span class="number">2</span>,,<span class="number">3</span>,,]</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生10个数组空位的数组</span></span><br><span class="line"><span class="keyword">let</span> arr3 = []</span><br><span class="line">arr3.<span class="property">length</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组a[3]-a[9]都是数组空位</span></span><br><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr4[<span class="number">10</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组arr[2]产生数组空位</span></span><br><span class="line"><span class="keyword">let</span> arr5 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>



<h4 id="数组的增删改查"><a href="#数组的增删改查" class="headerlink" title="数组的增删改查"></a>数组的增删改查</h4><ul>
<li>delect[n] 通过delect删除元素会形成稀疏数组，形成空位（存在空位，索引值不连续</li>
<li>arr[0] &#x3D;’xxx’</li>
<li>console.log(arr[0])</li>
</ul>
<p>数组的空位可以访问，值为<strong>underfinded</strong></p>
<p><strong>当数组为一个正常数组时，可以通过length来清楚数组（不存在索引值不为非数字的值</strong></p>
<p>数组遍历优化或提高效率</p>
<p>var len &#x3D; arr.length</p>
<p>for(;i&lt;len)</p>
<h2 id="api-接口方法"><a href="#api-接口方法" class="headerlink" title="api (接口方法)"></a>api (接口方法)</h2><ul>
<li><p><strong>push向数组的最后插入一个元素</strong> push(a,b)一次可以添加多个值，unshift同</p>
</li>
<li><p><strong>arr.shift() 删除第一个数据元素，并返回给我们删除的元素</strong></p>
</li>
<li><p><strong>pop() 删除数组的最后一个元素，并且返回删除的最后一个元素</strong></p>
</li>
<li><p><strong>unshift() 向数组的最前方插入一个元素</strong></p>
</li>
<li><p>splice(索引值，删除数组元素的个数，插入的元素) 删除元素 替换元素 插入元素</p>
<ul>
<li>删除<ul>
<li>arr.splice(1,1) 从索引一开始，删除一元素</li>
<li>arr.splice(1,1,’xxx’) 。。。 替换一元素 值为xxx</li>
<li>arr.splice(2,0,’xxx’) 在第三个位置插入xxx</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<p>所有的表单控件必须用value，初此之外必须使用，innerHtml,innerText</p>
<p>resize:none  -&gt;删除textarea的可变  不让其影响其他元素</p>
<p>dotted 虚线效果（solid）</p>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><ul>
<li><p>find </p>
</li>
<li><p>findIndex</p>
</li>
<li><p>forEach</p>
</li>
</ul>
<p>forEach(item,index)</p>
<p>find可以返回当前元素所在的数组</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="对象（object）"><a href="#对象（object）" class="headerlink" title="对象（object）"></a>对象（object）</h3><h4 id="对象包含两种-属性和方法"><a href="#对象包含两种-属性和方法" class="headerlink" title="对象包含两种 属性和方法"></a>对象包含两种 <strong>属性和方法</strong></h4><h4 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h4><p>var obj &#x3D; {}</p>
<ul>
<li><p>添加元素</p>
<p>obj[‘username’] &#x3D; ‘张三’   数组的key可以是数字或者字符串</p>
<p>var str &#x3D; ’like‘</p>
<p>obj[str] &#x3D; ‘电影’</p>
<ul>
<li>​    str 不加引号，可以作为变量被解析</li>
<li>obj.age &#x3D;&#x3D;&#x3D; obj[‘age’]<ul>
<li><strong>区别</strong>：方括号中可以解析变量，<strong>如上</strong></li>
</ul>
</li>
<li><strong>对象.一定是字符串</strong><ul>
<li>obj.str str默认为字符串</li>
</ul>
</li>
</ul>
</li>
<li><p>方法的写法</p>
<ul>
<li><p>obj[‘say’] &#x3D; function(){</p>
<p>….}</p>
</li>
<li><p>对象中的方法需要手动调用</p>
</li>
</ul>
</li>
<li><p>添加属性和方法</p>
<ul>
<li><p>&#96;&#96;&#96;js<br>&#x2F;&#x2F;创建对象时添加内容，一定采用key-value的形式</p>
<ul>
<li><ul>
<li>var obj &#x3D; {<br>}</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 变量名和对象名相同，需要在变量的外部加一个方括号</span><br><span class="line"></span><br><span class="line">    - [str]:&#x27;值&#x27;，</span><br><span class="line"></span><br><span class="line">- **key值的设定需要符合标识符命名规则**</span><br><span class="line"></span><br><span class="line">- 对象的方法里面如何使用对象的属性和方法 （this代表事件源）</span><br><span class="line"></span><br><span class="line">  - this放在对象的方法中，即指向该对象</span><br><span class="line"></span><br><span class="line">- 向对象中添加属性和方法 </span><br><span class="line"></span><br><span class="line">  - obj.a = &#x27;&#x27;;</span><br><span class="line">  - obj.c = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">- 删除数组 中的属性和方法</span><br><span class="line"></span><br><span class="line">  - delece obj.a;</span><br><span class="line">  - object obj[&#x27;&#x27;];</span><br><span class="line"></span><br><span class="line">- 取或调用数组中的属性和方法</span><br><span class="line"></span><br><span class="line">- 遍历对象</span><br><span class="line"></span><br><span class="line">  - ​	`for(var key in obj)&#123;`</span><br><span class="line"></span><br><span class="line">    ​	`console.log(obj[key])`</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">- 1</span><br><span class="line"></span><br><span class="line">### 对象和数组进行比较</span><br><span class="line"></span><br><span class="line">1. //数组时有序的，对象是无序的</span><br><span class="line">2. 数组的key必须是number 对象的key是字符串，数组是一种特殊的对象，虽然数组的key是number，但在解析时，会被自动转换成字符串</span><br><span class="line">3. 数组操作元素只能[]对象，对象可以通过  .  和 []</span><br><span class="line">4. 数组的遍历可以使用foreach，for ，for in，对象只能使用for in</span><br><span class="line">5. 当key值重复时，value会发生覆盖</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 对象方法Object.keys(object)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 函数</span><br><span class="line"></span><br><span class="line">##### 定义 ：一段代码的集合体</span><br><span class="line"></span><br><span class="line">特点：不调用时为静止片段，不调用不执行。减少工作量</span><br><span class="line"></span><br><span class="line">#### 创建函数的方式</span><br><span class="line"></span><br><span class="line">1. function 函数名()&#123;</span><br><span class="line"></span><br><span class="line">   语句；</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">2. 函数表达式</span><br><span class="line"></span><br><span class="line">   - var 。。。 = function    在js中，函数地位和基础数据类型相同，数据能做什么，函数就能做什么</span><br><span class="line"></span><br><span class="line">   var 变量 = function()&#123;</span><br><span class="line"></span><br><span class="line">   ​	语句；</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   - ​	将函数放在函数的右边，js引擎就会把函数理解为一个表达式</span><br><span class="line">   - 一般来说说，表达式都放在等号的右边</span><br><span class="line"></span><br><span class="line">3. var fn = new function()&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 函数名</span><br><span class="line"></span><br><span class="line">理解为变量名  -&gt; 符合标识符命名规则</span><br><span class="line"></span><br><span class="line">- ​	给函数起名字时，不要首字母大小，</span><br><span class="line">  - 凡是大写字母开头都是构造函数</span><br><span class="line">- 形参和实参</span><br><span class="line">  - 形参：理解为只能用在内部的变量</span><br><span class="line">    - 调用函数的时候给形参赋值，即实参赋值给形参</span><br><span class="line">  - 实参：</span><br><span class="line">  - ps：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 返回值</span><br><span class="line"></span><br><span class="line">需求:通过add函数计算出100+200的值，然后通过msg函数结果以弹窗将结果以弹窗的形式弹出</span><br><span class="line"></span><br><span class="line">- 将函数处理后的结果在函数外拿到</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### callback回调函数</span><br><span class="line"></span><br><span class="line">把函数当参数传递给另一个函数</span><br><span class="line"></span><br><span class="line">##### 没有名字的函数叫匿名函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 函数创建方式：</span><br><span class="line">   1. `function`关键字 </span><br><span class="line">   2. 函数表达式</span><br><span class="line">   3. 构造函数</span><br><span class="line"></span><br><span class="line">&gt; 通过函数表达式创建的函数不能提前使用。因为函数表达式的创建形式相当于是把一个匿名函数赋值给了变量，虽然变量和函数都会提升，但是赋值的操作不会提升。所以也就不能提前使用函数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 不管是变量也好还是函数也好，提升终归不是一个好的事情，所以对于程序员来说，知道这个规则但是我们尽量不去使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">// 尽量不在函数体之前使用函数</span><br><span class="line">fn1();</span><br><span class="line">function fn1() &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol start="2">
<li>函数名<ol>
<li>函数的命名遵守标识符的规则</li>
<li>尽量不要首字母大写，因为在js中首字母大写是属于构造函数(class类)</li>
</ol>
</li>
<li>函数的参数<ol>
<li>形参(创建函数时，函数名之后的括号里放的就是形参列表)</li>
<li>实参(调用函数时，函数名后面的括号放的就是实参列表)</li>
</ol>
</li>
</ol>
<p>​    关于形参和实参：</p>
<ol>
<li><p>形参的个数多于实参的个数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a,b,c</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn1</span>(<span class="number">10</span>,<span class="number">20</span>); </span><br></pre></td></tr></table></figure>

<p>多余的形参值是undefined。</p>
<blockquote>
<p>完全可以把形参理解为js中的变量，只不过这个变量只能用在函数中，而实参其实就是给这个变量赋值。</p>
<p>如果实参的个数少于形参，那就会出现多余的形参没有被赋值，自然结果就和未赋值的变量相同。</p>
</blockquote>
</li>
<li><p>实参的个数多余形参的个数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a,b</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">fn1</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<p>当实参的个数多于形参的个数时，想要找到多余的实参，可以利用arguments(js提供的专门在函数当中使用的类数组对象)。</p>
<p>可以通过arguments.length获取实参的个数。</p>
<p>可以通过arguments.callee.length 获取形参的个数。</p>
</li>
<li><p>函数返回值</p>
<p>js的函数一旦创建完毕，那么就会在内存中停留但是不会被执行，只有函数调用的时候，函数代码才会执行。在执行的过程中如果碰到了return，那么函数就会立刻停止执行。</p>
<p>在一个函数中，同一时刻有且仅有一个return可以生效。</p>
<p>return只能返回一个值。</p>
</li>
</ol>
<hr>
<ol>
<li><p>作用域和变量</p>
<ol>
<li>作用域：代码生效的范围。</li>
</ol>
<p>在es5当中，作用域只有两个：</p>
<ol>
<li>全局作用域：整个script存在的空间</li>
<li>函数作用域：函数内部的空间</li>
</ol>
</li>
</ol>
<p>既然存在两个作用域，那么对应的在不同作用域下声明的变量，也就有了不同的称呼：</p>
<ul>
<li>全局变量(在全局作用域下声明的变量，生效范围全局)</li>
<li>局部变量(在函数内部声明的变量，生效范围仅限于函数的内部)</li>
</ul>
<ol start="2">
<li><p>作用域链</p>
<p><em>由小范围的作用域不断向上延申扩展最终形成的一系列作用域，称之为作用域链。</em></p>
</li>
<li><p>生命周期和垃圾回收机制</p>
</li>
<li><p>闭包函数</p>
<ol>
<li>在函数内部将一个函数当作返回值返回，这样的函数结构称之为闭包函数。</li>
<li>特点：返回的函数可以任意的通过作用域链拿到上一层函数的值。<ol>
<li>会将状态保存，并不会在函数执行完毕之后销毁函数内部的变量。</li>
</ol>
</li>
<li>缺点：不会及时的被销毁。</li>
</ol>
</li>
<li><p>回调函数</p>
<p>函数在js中是一等公民，所以基础数据类型能干的事，函数也可以干。</p>
<p>所以就可以拿函数当作一个参数传递给另外一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsq</span>(<span class="params">num1, num2, cb</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">cb</span>(num1, num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>递归函数</p>
<p>所谓的递归函数就是在函数体内调用本函数。</p>
</li>
<li><p>IIFE</p>
</li>
</ol>
<h3 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> temp = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> demo = <span class="title function_">test</span>();</span><br><span class="line"><span class="title function_">demo</span>();</span><br><span class="line"><span class="comment">// 凡是多个函数嵌套，里面的函数都保存到了外部函数的外部（即外部)里面函数在执行时，可以继续访问外部函数未销毁之前外部变量函数的变量，且不会报错</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典闭包案例</span></span><br><span class="line"><span class="comment">//闭包里面的匿名函数，先不去找i的值，仅仅先创建了10个闭包函数，最后执行完循环，i=10不满足条件，然后执行这些闭包函数</span></span><br><span class="line"><span class="comment">//    此时再来找i的值，i的值未10，最终结果为10个10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">			arr[i] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">				documen.<span class="title function_">write</span>(i+<span class="string">&#x27; &#x27;</span>);	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> myArr = <span class="title function_">test</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j &lt; <span class="number">10</span>;j++)&#123;</span><br><span class="line">	myArr[j]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;            <span class="keyword">var</span> divall = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);            divall.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;noteSome&#x27;</span>);            divall.<span class="property">innerHTML</span> = <span class="title function_">getModule</span>(arr[i].<span class="property">ipt_value</span>, arr[i].<span class="property">text_value</span>, arr[i].<span class="property">time</span>, arr[i].<span class="property">note_id</span>)            artile.<span class="title function_">append</span>(divall);</span><br></pre></td></tr></table></figure>



<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="1-获取字符串长度"><a href="#1-获取字符串长度" class="headerlink" title="1. 获取字符串长度"></a>1. 获取字符串长度</h4><p>JavaScript中的字符串有一个length属性，该属性可以用来获取字符串的长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello&#x27;</span>;str.<span class="property">length</span>   <span class="comment">// 输出结果：5复制代码</span></span><br></pre></td></tr></table></figure>

<h4 id="2-获取字符串指定位置的值"><a href="#2-获取字符串指定位置的值" class="headerlink" title="2. 获取字符串指定位置的值"></a>2. 获取字符串指定位置的值</h4><p>charAt()和charCodeAt()方法都可以通过索引来获取指定位置的值：</p>
<ul>
<li>charAt() 方法获取到的是指定位置的字符；</li>
<li>charCodeAt()方法获取的是指定位置字符的Unicode值。</li>
</ul>
<h4 id="（1）charAt"><a href="#（1）charAt" class="headerlink" title="（1）charAt()"></a>（1）charAt()</h4><p>charAt() 方法可以返回指定位置的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">charAt</span>(index)复制代码</span><br></pre></td></tr></table></figure>

<p>index表示字符在字符串中的索引值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">str.<span class="title function_">charAt</span>(<span class="number">1</span>)  <span class="comment">// 输出结果：e </span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们知道，字符串也可以通过索引值来直接获取对应字符，那它和charAt()有什么区别呢？来看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">str.<span class="title function_">charAt</span>(<span class="number">1</span>)  <span class="comment">// 输出结果：e </span></span><br><span class="line">str[<span class="number">1</span>]         <span class="comment">// 输出结果：e </span></span><br><span class="line">str.<span class="title function_">charAt</span>(<span class="number">5</span>)  <span class="comment">// 输出结果：&#x27;&#x27; </span></span><br><span class="line">str[<span class="number">5</span>]         <span class="comment">// 输出结果：undefined</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到，当index的取值不在str的长度范围内时，str[index]会返回undefined，而charAt(index)会返回空字符串；除此之外，str[index]不兼容ie6-ie8，charAt(index)可以兼容。</p>
<h4 id="（2）charCodeAt"><a href="#（2）charCodeAt" class="headerlink" title="（2）charCodeAt()"></a>（2）charCodeAt()</h4><p><code>charCodeAt()</code>：该方法会返回指定索引位置字符的 Unicode 值，返回值是 0 - 65535 之间的整数，表示给定索引处的 UTF-16 代码单元，如果指定位置没有字符，将返回 <strong>NaN</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charCodeAt</span>(<span class="number">1</span>)); <span class="comment">// &quot;b&quot; --&gt; 98</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过这个方法，可以获取字符串中指定Unicode编码值范围的字符。比如，数字0～9的Unicode编码范围是: 48～57，可以通过这个方法来筛选字符串中的数字，当然如果你更熟悉正则表达式，会更方便。</p>
<h4 id="3-检索字符串是否包含特定序列"><a href="#3-检索字符串是否包含特定序列" class="headerlink" title="3. 检索字符串是否包含特定序列"></a>3. 检索字符串是否包含特定序列</h4><p>这5个方法都可以用来检索一个字符串中是否包含特定的序列。其中前两个方法得到的指定元素的索引值，并且只会返回第一次匹配到的值的位置。后三个方法返回的是布尔值，表示是否匹配到指定的值。</p>
<p>注意：这5个方法都对大小写敏感！</p>
<h4 id="（1）indexOf"><a href="#（1）indexOf" class="headerlink" title="（1）indexOf()"></a>（1）indexOf()</h4><p><code>indexOf()</code>：查找某个字符，<strong>有则返回第一次匹配到的位置</strong>，否则返回-1，其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">indexOf</span>(searchvalue,fromindex)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，规定需检索的字符串值；</li>
<li>fromindex：可选的整数参数，规定在字符串中开始检索的位置。它的合法取值是 0 到 string.length - 1。如省略该，则从字符串的首字符开始检索。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcdefgabc&quot;</span>;<span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;a&quot;</span>));   <span class="comment">// 输出结果：0console.log(str.indexOf(&quot;z&quot;));   // 输出结果：-1console.log(str.indexOf(&quot;c&quot;, 4)) // 输出结果：9复制代码</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）lastIndexOf"><a href="#（2）lastIndexOf" class="headerlink" title="（2）lastIndexOf()"></a>（2）lastIndexOf()</h4><p><code>lastIndexOf()</code>：查找某个字符，有则返回最后一次匹配到的位置，否则返回-1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcabc&quot;</span>;<span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;a&quot;</span>));  <span class="comment">// 输出结果：3console.log(str.lastIndexOf(&quot;z&quot;));  // 输出结果：-1复制代码</span></span><br></pre></td></tr></table></figure>

<p>该方法和indexOf()类似，只是查找的顺序不一样，indexOf()是正序查找，lastIndexOf()是逆序查找。</p>
<h4 id="（3）includes"><a href="#（3）includes" class="headerlink" title="（3）includes()"></a>（3）includes()</h4><p><code>includes()</code>：该方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。该方法的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">includes</span>(searchvalue, start)复制代码</span><br></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，要查找的字符串；</li>
<li>start：可选，设置从那个位置开始查找，默认为 0。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello world!&#x27;</span>;str.<span class="title function_">includes</span>(<span class="string">&#x27;o&#x27;</span>)  <span class="comment">// 输出结果：truestr.includes(&#x27;z&#x27;)  // 输出结果：falsestr.includes(&#x27;e&#x27;, 2)  // 输出结果：false复制代码</span></span><br></pre></td></tr></table></figure>

<h4 id="（4）startsWith"><a href="#（4）startsWith" class="headerlink" title="（4）startsWith()"></a>（4）startsWith()</h4><p><code>startsWith()</code>：该方法用于检测字符串<strong>是否以指定的子字符串开始</strong>。如果是以指定的子字符串开头返回 true，否则 false。其语法和上面的includes()方法一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello world!&#x27;</span>;str.<span class="title function_">startsWith</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// 输出结果：truestr.startsWith(&#x27;Helle&#x27;) // 输出结果：falsestr.startsWith(&#x27;wo&#x27;, 6) // 输出结果：true复制代码</span></span><br></pre></td></tr></table></figure>

<h4 id="（5）endsWith"><a href="#（5）endsWith" class="headerlink" title="（5）endsWith()"></a>（5）endsWith()</h4><p><code>endsWith()</code>：该方法用来判断当前字符串<strong>是否是以指定的子字符串结尾</strong>。如果传入的子字符串在搜索字符串的末尾则返回 true，否则将返回 false。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">endsWith</span>(searchvalue, length)复制代码</span><br></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，要搜索的子字符串；</li>
<li>length： 设置字符串的长度，默认值为原始字符串长度 string.length。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello world!&#x27;</span>;str.<span class="title function_">endsWith</span>(<span class="string">&#x27;!&#x27;</span>)       <span class="comment">// 输出结果：truestr.endsWith(&#x27;llo&#x27;)     // 输出结果：falsestr.endsWith(&#x27;llo&#x27;, 5)  // 输出结果：true复制代码</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>当第二个参数设置为5时，就会从字符串的前5个字符中进行检索，所以会返回true。</strong></p>
<h4 id="4-连接多个字符串"><a href="#4-连接多个字符串" class="headerlink" title="4. 连接多个字符串"></a>4. 连接多个字符串</h4><p>concat() 方法用于连接两个或多个字符串。该方法不会改变原有字符串，会返回连接两个或多个字符串的新字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">concat</span>(string1, string2, ..., stringX)复制代码</span><br></pre></td></tr></table></figure>

<p>其中参数 string1, string2, …, stringX 是必须的，他们将被连接为一个字符串的一个或多个字符串对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abc&quot;</span>;<span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">concat</span>(<span class="string">&quot;efg&quot;</span>));          <span class="comment">//输出结果：&quot;abcefg&quot;console.log(str.concat(&quot;efg&quot;,&quot;hijk&quot;)); //输出结果：&quot;abcefghijk&quot;复制代码</span></span><br></pre></td></tr></table></figure>

<p>虽然concat()方法是专门用来拼接字符串的，但是在开发中使用最多的还是加操作符+，因为其更加简单。</p>
<h4 id="5-字符串分割成数组"><a href="#5-字符串分割成数组" class="headerlink" title="5. 字符串分割成数组"></a>5. 字符串分割成数组</h4><p>split() 方法用于把一个字符串分割成字符串数组。该方法不会改变原始字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">split</span>(separator,limit)复制代码</span><br></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>separator：必需。字符串或正则表达式，从该参数指定的地方分割 string。</li>
<li>limit：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&quot;c&quot;</span>);    <span class="comment">// 输出结果：[&quot;ab&quot;, &quot;def&quot;]</span></span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>, <span class="number">4</span>)   <span class="comment">// 输出结果：[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] </span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果把空字符串用作 separator，那么字符串中的每个字符之间都会被分割。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);     <span class="comment">// 输出结果：[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>其实在将字符串分割成数组时，可以同时拆分多个分割符，使用正则表达式即可实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="string">&quot;apples,bananas;cherries&quot;</span></span><br><span class="line"><span class="keyword">const</span> fruits = list.<span class="title function_">split</span>(<span class="regexp">/[,;]/</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits);  <span class="comment">// 输出结果：[&quot;apples&quot;, &quot;bananas&quot;, &quot;cherries&quot;]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="6-截取字符串"><a href="#6-截取字符串" class="headerlink" title="6. 截取字符串"></a>6. 截取字符串</h4><p>substr()、substring()和 slice() 方法都可以用来截取字符串。</p>
<h4 id="（1）-slice"><a href="#（1）-slice" class="headerlink" title="（1） slice()"></a>（1） slice()</h4><p>slice() 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">slice</span>(start,end)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>start：必须。 要截取的片断的起始下标，第一个字符位置为 0。如果为负数，则从尾部开始截取。</li>
<li>end：可选。 要截取的片段结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。</li>
</ul>
<p>上面说了，如果start是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">str.<span class="title function_">slice</span>(<span class="number">1</span>,<span class="number">6</span>);   <span class="comment">// 输出结果：&quot;bcdef&quot; </span></span><br><span class="line">str.<span class="title function_">slice</span>(<span class="number">1</span>);     <span class="comment">// 输出结果：&quot;bcdefg&quot; </span></span><br><span class="line">str.<span class="title function_">slice</span>();      <span class="comment">// 输出结果：&quot;abcdefg&quot; </span></span><br><span class="line">str.<span class="title function_">slice</span>(-<span class="number">2</span>);    <span class="comment">// 输出结果：&quot;fg&quot;</span></span><br><span class="line">str.<span class="title function_">slice</span>(<span class="number">6</span>, <span class="number">1</span>);  <span class="comment">// 输出结果：&quot;&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>注意，该方法返回的子串<strong>包括开始处的字符</strong>，但<strong>不包括结束处的字符</strong>。</p>
<h4 id="（2）-substr"><a href="#（2）-substr" class="headerlink" title="（2） substr()"></a>（2） substr()</h4><p>substr() 方法用于在字符串中抽取从开始下标开始的指定数目的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">substr</span>(start,length)复制代码</span><br></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>start    必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。</li>
<li>length：可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcdefg&quot;</span>;str.<span class="title function_">substr</span>(<span class="number">1</span>,<span class="number">6</span>); <span class="comment">// 输出结果：&quot;bcdefg&quot;</span></span><br><span class="line">str.<span class="title function_">substr</span>(<span class="number">1</span>);   <span class="comment">// 输出结果：&quot;bcdefg&quot; 相当于截取[1,str.length-1]</span></span><br><span class="line">str.<span class="title function_">substr</span>();    <span class="comment">// 输出结果：&quot;abcdefg&quot; 相当于截取[0,str.length-1]</span></span><br><span class="line">str.<span class="title function_">substr</span>(-<span class="number">1</span>);  <span class="comment">// 输出结果：&quot;g&quot;复制代码</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）-substring"><a href="#（3）-substring" class="headerlink" title="（3） substring()"></a>（3） substring()</h4><p>substring() 方法用于提取字符串中介于两个指定下标之间的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">substring</span>(<span class="keyword">from</span>, to)复制代码</span><br></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>from：必需。一个非负的整数，规定要提取的子串的第一个字符在 string 中的位置。</li>
<li>to：可选。一个非负的整数，比要提取的子串的最后一个字符在 string 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。</li>
</ul>
<p><strong>注意：</strong> 如果参数 from 和 to 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 from 比 to 大，那么该方法在提取子串之前会先交换这两个参数。并且该方法不接受负的参数，如果参数是个负数，就会返回这个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcdefg&quot;</span>;str.<span class="title function_">substring</span>(<span class="number">1</span>,<span class="number">6</span>); <span class="comment">// 输出结果：&quot;bcdef&quot; [1,6)</span></span><br><span class="line"> str.<span class="title function_">substring</span>(<span class="number">1</span>);   <span class="comment">// 输出结果：&quot;bcdefg&quot;[1,str.length-1]</span></span><br><span class="line">str.<span class="title function_">substring</span>();    <span class="comment">// 输出结果：&quot;abcdefg&quot; [0,str.length-1]</span></span><br><span class="line">str.<span class="title function_">substring</span>(<span class="number">6</span>,<span class="number">1</span>); <span class="comment">// 输出结果 &quot;bcdef&quot; [1,6)</span></span><br><span class="line">str.<span class="title function_">substring</span>(-<span class="number">1</span>);  <span class="comment">// 输出结果：&quot;abcdefg&quot;复制代码</span></span><br></pre></td></tr></table></figure>

<p>注意，该方法返回的子串<strong>包括开始处的字符</strong>，但<strong>不包括结束处的字符</strong>。</p>
<h4 id="7-字符串大小写转换"><a href="#7-字符串大小写转换" class="headerlink" title="7. 字符串大小写转换"></a>7. 字符串大小写转换</h4><p>toLowerCase() 和 toUpperCase()方法可以用于字符串的大小写转换。</p>
<h4 id="（1）toLowerCase"><a href="#（1）toLowerCase" class="headerlink" title="（1）toLowerCase()"></a>（1）toLowerCase()</h4><p><code>toLowerCase()</code>：该方法用于把字符串转换为小写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;adABDndj&quot;</span>;str.<span class="title function_">toLowerCase</span>(); <span class="comment">// 输出结果：&quot;adabdndj&quot;复制代码</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）toUpperCase"><a href="#（2）toUpperCase" class="headerlink" title="（2）toUpperCase()"></a>（2）toUpperCase()</h4><p><code>toUpperCase()</code>：该方法用于把字符串转换为大写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;adABDndj&quot;</span>;str.<span class="title function_">toUpperCase</span>(); <span class="comment">// 输出结果：&quot;ADABDNDJ&quot;复制代码</span></span><br></pre></td></tr></table></figure>

<p>我们可以用这个方法来将字符串中第一个字母变成大写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> word = <span class="string">&#x27;apple&#x27;</span></span><br><span class="line">word = word[<span class="number">0</span>].<span class="title function_">toUpperCase</span>() + word.<span class="title function_">substr</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(word) <span class="comment">// 输出结果：&quot;Apple&quot;复制代码</span></span><br></pre></td></tr></table></figure>

<h4 id="8-字符串模式匹配"><a href="#8-字符串模式匹配" class="headerlink" title="8. 字符串模式匹配"></a>8. 字符串模式匹配</h4><p>replace()、match()和search()方法可以用来匹配或者替换字符。</p>
<h4 id="（1）replace"><a href="#（1）replace" class="headerlink" title="（1）replace()"></a>（1）replace()</h4><p><code>replace()</code>：该方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">replace</span>(searchvalue, newvalue)复制代码</span><br></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需。规定子字符串或要替换的模式的 RegExp 对象。如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</li>
<li>newvalue：必需。一个字符串值。规定了替换文本或生成替换文本的函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">str.<span class="title function_">replace</span>(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;z&quot;</span>) <span class="comment">// 输出结果：abzdef</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>执行一个全局替换, 忽略大小写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">&quot;Mr Blue has a blue house and a blue car&quot;</span>;</span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/blue/gi</span>, <span class="string">&quot;red&quot;</span>);    <span class="comment">// 输出结果：&#x27;Mr red has a red house and a red car&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。</p>
<h4 id="（2）match"><a href="#（2）match" class="headerlink" title="（2）match()"></a>（2）match()</h4><p><code>match()</code>：该方法用于在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">match</span>(regexp)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>该方法的参数 regexp 是必需的，规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。</p>
<p><strong>注意：</strong> 该方法返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(<span class="string">&quot;c&quot;</span>)) <span class="comment">// [&quot;c&quot;, index: 2, input: &quot;abcdef&quot;, groups: undefined]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="（3）search"><a href="#（3）search" class="headerlink" title="（3）search()"></a>（3）search()</h4><p><code>search()</code>方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">search</span>(searchvalue)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>该方法的参数 regex 可以是需要在 string 中检索的子串，也可以是需要检索的 RegExp 对象。</p>
<p><strong>注意：</strong> 要执行忽略大小写的检索，请追加标志 i。该方法不执行全局匹配，它将忽略标志 g，也就是只会返回第一次匹配成功的结果。如果没有找到任何匹配的子串，则返回 -1。</p>
<p><strong>返回值：</strong> 返回 str 中第一个与 regexp 相匹配的子串的起始位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcdef&quot;</span>;str.<span class="title function_">search</span>(<span class="regexp">/bcd/</span>)   <span class="comment">// 输出结果：1复制代码</span></span><br></pre></td></tr></table></figure>

<h4 id="9-移除字符串收尾空白符"><a href="#9-移除字符串收尾空白符" class="headerlink" title="9. 移除字符串收尾空白符"></a>9. 移除字符串收尾空白符</h4><p>trim()、trimStart()和trimEnd()这三个方法可以用于移除字符串首尾的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等。</p>
<h4 id="（1）trim"><a href="#（1）trim" class="headerlink" title="（1）trim()"></a>（1）trim()</h4><p>trim() 方法用于移除字符串首尾空白符，该方法不会改变原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;  abcdef  &quot;</span>str.<span class="title function_">trim</span>()    <span class="comment">// 输出结果：&quot;abcdef&quot;复制代码</span></span><br></pre></td></tr></table></figure>

<p>注意，该方法不适用于null、undefined、Number类型。</p>
<h4 id="（2）trimStart"><a href="#（2）trimStart" class="headerlink" title="（2）trimStart()"></a>（2）trimStart()</h4><p>trimStart() 方法的的行为与<code>trim()</code>一致，不过会返回一个<strong>从原始字符串的开头删除了空白的新字符串</strong>，不会修改原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;  abc  &#x27;</span>;s.<span class="title function_">trimStart</span>()   <span class="comment">// &quot;abc  &quot;复制代码</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）trimEnd"><a href="#（3）trimEnd" class="headerlink" title="（3）trimEnd()"></a>（3）trimEnd()</h4><p>trimEnd() 方法的的行为与<code>trim()</code>一致，不过会返回一个<strong>从原始字符串的结尾删除了空白的新字符串</strong>，不会修改原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;  abc  &#x27;</span>;s.<span class="title function_">trimEnd</span>()   <span class="comment">// &quot;  abc&quot;复制代码</span></span><br></pre></td></tr></table></figure>

<h4 id="10-获取字符串本身"><a href="#10-获取字符串本身" class="headerlink" title="10. 获取字符串本身"></a>10. 获取字符串本身</h4><p>valueOf()和toString()方法都会返回字符串本身的值，感觉用处不大。</p>
<h4 id="（1）valueOf"><a href="#（1）valueOf" class="headerlink" title="（1）valueOf()"></a>（1）valueOf()</h4><p><code>valueOf()</code>：返回某个字符串对象的原始值，该方法通常由 JavaScript 自动进行调用，而不是显式地处于代码中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">valueOf</span>()) <span class="comment">// &quot;abcdef&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="（2）toString"><a href="#（2）toString" class="headerlink" title="（2）toString()"></a>（2）toString()</h4><p><code>toString()</code>：返回字符串对象本身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">toString</span>()) <span class="comment">// &quot;abcdef&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="11-重复一个字符串"><a href="#11-重复一个字符串" class="headerlink" title="11. 重复一个字符串"></a>11. 重复一个字符串</h4><p>repeat() 方法返回一个新字符串，表示将原字符串重复n次：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">3</span>)     <span class="comment">// 输出结果：&quot;xxx&quot;</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">2</span>) <span class="comment">// 输出结果：&quot;hellohello&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">0</span>)    <span class="comment">// 输出结果：&quot;&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果参数是小数，会向下取整：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">2.9</span>) <span class="comment">// 输出结果：&quot;nana&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果参数是负数或者Infinity，会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="title class_">Infinity</span>)   <span class="comment">// RangeError</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(-<span class="number">1</span>)         <span class="comment">// RangeError</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(-<span class="number">0.9</span>)   <span class="comment">// 输出结果：&quot;&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果参数是NaN，就等同于 0：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="title class_">NaN</span>)    <span class="comment">// 输出结果：&quot;&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果repeat的参数是字符串，则会先转换成数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="string">&#x27;na&#x27;</span>)   <span class="comment">// 输出结果：&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="string">&#x27;3&#x27;</span>)    <span class="comment">// 输出结果：&quot;nanana&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="12-补齐字符串长度"><a href="#12-补齐字符串长度" class="headerlink" title="12. 补齐字符串长度"></a>12. 补齐字符串长度</h4><p>padStart()和padEnd()方法用于补齐字符串的长度。如果某个字符串不够指定长度，会在头部或尾部补全。</p>
<h4 id="（1）padStart"><a href="#（1）padStart" class="headerlink" title="（1）padStart()"></a>（1）padStart()</h4><p><code>padStart()</code>用于头部补全。该方法有两个参数，其中第一个参数是一个数字，表示字符串补齐之后的长度；第二个参数是用来补全的字符串。 </p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">1</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;x&#x27;复制代码</span></span><br></pre></td></tr></table></figure>

<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;&#x27;x&#x27;.padStart(4, &#x27;ab&#x27;) // &#x27;abax&#x27;复制代码</span></span><br></pre></td></tr></table></figure>

<p>如果省略第二个参数，默认使用空格补全长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">4</span>) <span class="comment">// &#x27;   x&#x27;复制代码</span></span><br></pre></td></tr></table></figure>

<p>padStart()的常见用途是为数值补全指定位数，笔者最近做的一个需求就是将返回的页数补齐为三位，比如第1页就显示为001，就可以使用该方法来操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;1&quot;</span>.<span class="title function_">padStart</span>(<span class="number">3</span>, <span class="string">&#x27;0&#x27;</span>)   <span class="comment">// 输出结果： &#x27;001&#x27;</span></span><br><span class="line"><span class="string">&quot;15&quot;</span>.<span class="title function_">padStart</span>(<span class="number">3</span>, <span class="string">&#x27;0&#x27;</span>)  <span class="comment">// 输出结果： &#x27;015&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="（2）padEnd"><a href="#（2）padEnd" class="headerlink" title="（2）padEnd()"></a>（2）padEnd()</h4><p><code>padEnd()</code>用于尾部补全。该方法也是接收两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="13-字符串转为数字"><a href="#13-字符串转为数字" class="headerlink" title="13. 字符串转为数字"></a>13. 字符串转为数字</h4><p>parseInt()和parseFloat()方法都用于将字符串转为数字。</p>
<h4 id="（1）parseInt"><a href="#（1）parseInt" class="headerlink" title="（1）parseInt()"></a>（1）parseInt()</h4><p>parseInt() 方法用于可解析一个字符串，并返回一个整数。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(string, radix)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>string：必需。要被解析的字符串。</li>
<li>radix：可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</li>
</ul>
<p>当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>);			  <span class="comment">// 输出结果：10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;17&quot;</span>,<span class="number">8</span>);		  <span class="comment">// 输出结果：15 (8+7)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;010&quot;</span>);		  <span class="comment">// 输出结果：10 或 8</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当参数 radix 的值以 “0x” 或 “0X” 开头，将以 16 为基数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0x10&quot;</span>)      <span class="comment">// 输出结果：16</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;50&quot;</span>, <span class="number">1</span>)      <span class="comment">// 输出结果：NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;50&quot;</span>, <span class="number">40</span>)     <span class="comment">// 输出结果：NaN</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>只有字符串中的第一个数字会被返回，当遇到第一个不是数字的字符为止:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;40 4years&quot;</span>)   <span class="comment">// 输出结果：40</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果字符串的第一个字符不能被转换为数字，就会返回 NaN：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;new100&quot;</span>)     <span class="comment">// 输出结果：NaN</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>字符串开头和结尾的空格是允许的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;  60  &quot;</span>)    <span class="comment">// 输出结果： 60</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="（2）parseFloat"><a href="#（2）parseFloat" class="headerlink" title="（2）parseFloat()"></a>（2）parseFloat()</h4><p>parseFloat() 方法可解析一个字符串，并返回一个浮点数。该方法指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(string)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>parseFloat 将它的字符串参数解析成为浮点数并返回。如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;10.00&quot;</span>)      <span class="comment">// 输出结果：10.00</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;10.01&quot;</span>)      <span class="comment">// 输出结果：10.01</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;-10.01&quot;</span>)     <span class="comment">// 输出结果：-10.01</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;40.5 years&quot;</span>) <span class="comment">// 输出结果：40.5</span></span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;new40.5&quot;</span>)    <span class="comment">// 输出结果：NaN</span></span><br></pre></td></tr></table></figure>



<p>编码和解码 encode URI() 和 encodeURICompoent()</p>
<p><img src= "/hexo/loading" data-lazy-src="/hexo/%E5%AD%A6%E4%B9%A0/mdimages/image-20211213203747451.png" alt="image-20211213203747451"></p>
<h3 id="数组方法-1"><a href="#数组方法-1" class="headerlink" title="数组方法"></a>数组方法</h3><h4 id="1-测试所有元素"><a href="#1-测试所有元素" class="headerlink" title="1.测试所有元素"></a>1.测试所有元素</h4><ul>
<li><h4 id="every（）"><a href="#every（）" class="headerlink" title="every（）"></a>every（）</h4><ul>
<li>测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</li>
<li>里面时一个回调函数 留可以传index item array(原数组)</li>
</ul>
</li>
</ul>
<h4 id="2-填充一个数组中从起始索引到终止索引内的全部元素。-fill"><a href="#2-填充一个数组中从起始索引到终止索引内的全部元素。-fill" class="headerlink" title="2.填充一个数组中从起始索引到终止索引内的全部元素。(fill)"></a>2.填充一个数组中从起始索引到终止索引内的全部元素。(fill)</h4><ul>
<li><h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4></li>
<li><p>前提，数组已经存在位置，如果数组为空或未初始化则无效</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill with 0 from position 2 until position 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1.<span class="title function_">fill</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: [1, 2, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fill with 5 from position 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1.<span class="title function_">fill</span>(<span class="number">5</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// expected output: [1, 5, 5, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1.<span class="title function_">fill</span>(<span class="number">6</span>));</span><br><span class="line"><span class="comment">// expected output: [6, 6, 6, 6]</span></span><br><span class="line"></span><br><span class="line">item start conut</span><br><span class="line">第一个参数：用item填充 必须</span><br><span class="line">第二个参数：填充开始的位置 省略则为<span class="number">0</span></span><br><span class="line">第三分参数：填充多少个  默认为length</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-合并两个或多个数组。"><a href="#3-合并两个或多个数组。" class="headerlink" title="3.合并两个或多个数组。"></a>3.合并两个或多个数组。</h4><ul>
<li><h4 id="concat-方法"><a href="#concat-方法" class="headerlink" title="**concat()** 方法"></a><code>**concat()**</code> 方法</h4></li>
<li><p>&#96;&#96;&#96; js<br>&#x2F;&#x2F;合并多个数组<br>var num1 &#x3D; [1, 2, 3],<br>num2 &#x3D; [4, 5, 6],<br>num3 &#x3D; [7, 8, 9];<br>var nums &#x3D; num1.concat(num2, num3);<br>console.log(nums);<br>&#x2F;&#x2F; results in [1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
<p>&#x2F;&#x2F;将值连接到数组<br>&#x2F;&#x2F; 和下面合并多维很相似<br>var alpha &#x3D; [‘a’, ‘b’, ‘c’];<br>var alphaNumeric &#x3D; alpha.concat(1, [2, 3]);<br>console.log(alphaNumeric);<br>&#x2F;&#x2F; results in [‘a’, ‘b’, ‘c’, 1, 2, 3]</p>
<p>&#x2F;&#x2F;合并多维数组<br>&#x2F;&#x2F;会把第一层[]拆开拿到里面的元素<br>var num1 &#x3D; [[1]];<br>var num2 &#x3D; [2, [3]];<br>var num3&#x3D;[5,[6]];<br>var nums &#x3D; num1.concat(num2);<br>console.log(nums);<br>&#x2F;&#x2F; results is [[1], 2, [3]]</p>
<p>&#x2F;&#x2F;混合合并<br>var nums2&#x3D;num1.concat(4,num3);<br>console.log(nums2)<br>&#x2F;&#x2F; results is [[1], 4, 5,[6]]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 4.过滤所有元素</span><br><span class="line"></span><br><span class="line">	##### filter()</span><br><span class="line"></span><br><span class="line">- ##### 将满足条件的放入一个新数组</span><br><span class="line"></span><br><span class="line">  - 里面为一个回调函数 </span><br><span class="line"></span><br><span class="line">  - element  数组中当前正在处理的元素。</span><br><span class="line"></span><br><span class="line">  - ndex 数组中当前正在处理的元素的索引</span><br><span class="line"></span><br><span class="line">  - array（调用了 `filter` 的数组本身。）</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    var arr = [</span><br><span class="line">      &#123; id: 15 &#125;,</span><br><span class="line">      &#123; id: -1 &#125;,</span><br><span class="line">      &#123; id: 0 &#125;,</span><br><span class="line">      &#123; id: 3 &#125;,</span><br><span class="line">      &#123; id: 12.2 &#125;,</span><br><span class="line">      &#123; &#125;,</span><br><span class="line">      &#123; id: null &#125;,</span><br><span class="line">      &#123; id: NaN &#125;,</span><br><span class="line">      &#123; id: &#x27;undefined&#x27; &#125;</span><br><span class="line">    ];</span><br><span class="line">    </span><br><span class="line">    var invalidEntries = 0;</span><br><span class="line">    </span><br><span class="line">    function isNumber(obj) &#123;</span><br><span class="line">      return obj !== undefined &amp;&amp; typeof(obj) === &#x27;number&#x27; &amp;&amp; !isNaN(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function filterByID(item) &#123;</span><br><span class="line">      if (isNumber(item.id) &amp;&amp; item.id !== 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">      invalidEntries++;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var arrByID = arr.filter(filterByID);</span><br><span class="line">    </span><br><span class="line">    console.log(&#x27;Filtered Array\n&#x27;, arrByID);</span><br><span class="line">    // Filtered Array</span><br><span class="line">    // [&#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;]</span><br><span class="line">    </span><br><span class="line">    console.log(&#x27;Number of Invalid Entries = &#x27;, invalidEntries);</span><br><span class="line">    // Number of Invalid Entries = 5</span><br></pre></td></tr></table></figure>

<h3 id="5-遍历数组"><a href="#5-遍历数组" class="headerlink" title="5.遍历数组"></a>5.遍历数组</h3><ul>
<li><p>（1）forEach</p>
<ol>
<li><p>可以改变数组自身，没有返回值；</p>
</li>
<li><p>中途不能用常规操作跳出循环，可以用抛出异常（try&#x2F;catch）的方式，但不推荐这样做；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">&#x27;鸣人&#x27;</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">&#x27;佐助&#x27;</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr1.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123; </span><br><span class="line">  item.<span class="property">age</span> = item.<span class="property">age</span> + <span class="number">1</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>当数组中元素是值类型，forEach绝对不会改变数组；当是引用类型，则可以改变数组</strong></p>
<p>（2）map() 映射</p>
</li>
</ol>
<p>原数组被”映射”成对应新数组。</p>
<ul>
<li>新建一个数组，需要有承载对象，也意味着原始数组在调用它后不会发生变化;</li>
<li>该数组中的每个元素都调用一个提供的函数后返回结果。</li>
</ul>
<p>创建新数组不代表不能用它改变原有数组，你用原有数组去承载就可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line">arr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="keyword">return</span> item * <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>map()中每个元素都要执行相应的回调函数，所以必须要有return</li>
<li>如果你想给数组做一定的过滤处理，那map()基本上行不通：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="keyword">if</span>(item &gt; <span class="number">3</span>) <span class="keyword">return</span> item &#125;)</span><br><span class="line"><span class="comment">// =&gt; [undefined, undefined, undefined, 4, 5]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>不能凑合用， 人生不能凑合，代码也是！</p>
<p>（3)fliter() 过滤</p>
<ul>
<li><pre><code> 创建一个新数组，新数组中的元素是筛选出来的符合条件的所有对象。
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(item &gt; <span class="number">3</span>) <span class="keyword">return</span> item </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//  =&gt; [4,5]</span></span><br></pre></td></tr></table></figure>

<p>​            (4)sort()排序</p>
<ul>
<li><p>sort()用于对数组的元素进行排序。排序顺序可以是字母或数字，并按升序或降序。</p>
</li>
<li><p>​    sort()与map()、filter()等不同，它直接改变原始数组（很重要！）；</p>
</li>
<li><p>如果想按照其他标准进行排序，就需提供比较函数compareFunction(a,b)，数组会按照调用该函数的返回值排序，即a和b是两个将要比较的元素：</p>
<ul>
<li>如果compareFunction(a,b)小于0，则a排列到b之前；</li>
<li>如果 compareFunction(a, b)等于0，a和b的相对位置不变（并不保证）;</li>
<li>如果 compareFunction(a, b)大于0，b排列到a之前； 直接上例子：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Users</span> = [</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;鸣人&#x27;</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;卡卡西&#x27;</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;自来也&#x27;</span>,<span class="attr">age</span>:<span class="number">50</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;佐助&#x27;</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="title class_">Users</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a.<span class="property">age</span> - b.<span class="property">age</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; 鸣人、佐助、卡卡西、自来也</span></span><br></pre></td></tr></table></figure>



<p>(5)检索存在</p>
<ul>
<li><p>​    some()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">&#x27;鸣人&#x27;</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">&#x27;佐助&#x27;</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;</span><br><span class="line">].<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> item.<span class="property">age</span> &gt; <span class="number">16</span> </span><br><span class="line">&#125;);</span><br><span class="line">=&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>every()</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">&#x27;鸣人&#x27;</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">&#x27;佐助&#x27;</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;</span><br><span class="line">].<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> item.<span class="property">age</span> &gt; <span class="number">16</span> </span><br><span class="line">&#125;);</span><br><span class="line">=&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>some()和every()返回的都是<code>Boolean</code>值，仅此而此</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-数组去重"><a href="#6-数组去重" class="headerlink" title="6.数组去重"></a>6.数组去重</h4><ul>
<li>​    new Set( )     经典方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tempArr = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment">// =&gt; &#123;1,2,3,4,5&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//并且已有元素是添加不进去的：</span></span><br><span class="line">tempArr.<span class="title function_">add</span>(<span class="number">3</span>) </span><br><span class="line"><span class="comment">// =&gt; &#123;1,2,3,4,5&#125;</span></span><br><span class="line"></span><br><span class="line">tempArr.<span class="title function_">add</span>(<span class="number">6</span>)</span><br><span class="line"><span class="comment">// =&gt; &#123;1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p>​                     <strong>Set()没法去重元素是引用对象的数组。</strong></p>
<ul>
<li><h4 id="uniqWith-js库"><a href="#uniqWith-js库" class="headerlink" title="_.uniqWith()     js库"></a>_.uniqWith()     js库</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> objects = [&#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span> &#125;, &#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span> &#125;];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">_.<span class="title function_">uniqWith</span>(objects, _.<span class="property">isEqual</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; [&#123; &#x27;x&#x27;: 1, &#x27;y&#x27;: 2 &#125;, &#123; &#x27;x&#x27;: 2, &#x27;y&#x27;: 1 &#125;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//_.isEqual(value,other)用于执行深比较来确定两者的值是否相等。 _.uniqWith()做去重处理。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-查找元素"><a href="#7-查找元素" class="headerlink" title="7.查找元素"></a>7.查找元素</h4><ul>
<li>findIndex（）</li>
</ul>
<p>通过对象属性值直接获取对应索引： <code>**findIndex()**</code> 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>。</p>
<ul>
<li>find（）</li>
</ul>
<p><code>find()</code>顾名思义，就是用来在数组中找到我们所需要的元素</p>
<h4 id="8-回调地狱"><a href="#8-回调地狱" class="headerlink" title="8.回调地狱"></a>8.回调地狱</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调地狱</span></span><br><span class="line">    <span class="title function_">ajax</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;./a.json&#x27;</span>, <span class="keyword">function</span> (<span class="params">info</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (info.<span class="property">addr</span> != <span class="string">&#x27;ok&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">ajax</span>(<span class="string">&#x27;get&#x27;</span>, info.<span class="property">addr</span>, <span class="keyword">function</span> (<span class="params">info</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (info.<span class="property">addr</span> != <span class="string">&#x27;ok&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">ajax</span>(<span class="string">&#x27;get&#x27;</span>, info.<span class="property">addr</span>, <span class="keyword">function</span> (<span class="params">info</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (info.<span class="property">addr</span> == <span class="string">&#x27;ok&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(info.<span class="property">msg</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<h4 id="9-eval"><a href="#9-eval" class="headerlink" title="9.eval"></a>9.eval</h4><p>它的功能是将对应的字符串解析成 JS 并执行，应该避免使用 JS，因为非常消耗性能（2 次，一次解析成 JS，一次执行）</p>
<h4 id="10-copyWithin"><a href="#10-copyWithin" class="headerlink" title="10.copyWithin"></a>10.copyWithin</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>他会影响原数组，返回的数据和原数据为同一引用</p>
</li>
<li><p>&#96;&#96;&#96;js<br>[1, 2, 3, 4, 5].copyWithin(-2)<br>&#x2F;&#x2F; [1, 2, 3, 1, 2]</p>
<p>[1, 2, 3, 4, 5].copyWithin(0, 3)<br>&#x2F;&#x2F; [4, 5, 3, 4, 5]</p>
<p>[1, 2, 3, 4, 5].copyWithin(0, 3, 4)<br>&#x2F;&#x2F; [4, 2, 3, 4, 5]</p>
<p>[1, 2, 3, 4, 5].copyWithin(-2, -3, -1)<br>&#x2F;&#x2F; [1, 2, 3, 3, 4]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 11.call bind apply</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">//第一个参数 都是this 的指向，后面的参数则都是传递的参数</span><br><span class="line">// call 和 bind 传递参数都是： a,b,c...的形式</span><br><span class="line">  //而apply后面传递的参数应该为数组形式，就算是单个数据也要写成数组的形式 ：[&#x27;a&#x27;]</span><br><span class="line">//bind和call存在的区别在于，call和apply都会立即执行函数，而bind则不会。因此可以用bind写事件处理函数</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype ---》数组的实例化对象的原型 ---》this 指向数组的实例化对象</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a,b,c</span>) &#123;</span><br><span class="line">     <span class="comment">// arguments  foreach</span></span><br><span class="line">     <span class="comment">// es5中非常重要的写法</span></span><br><span class="line">     <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">fn1</span>(<span class="string">&#x27;哈哈哈&#x27;</span>, <span class="string">&#x27;嘿嘿嘿&#x27;</span>, <span class="string">&#x27;呵呵呵&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btn&#x27;</span>);</span><br><span class="line">    <span class="comment">// call apply bind 改变this指向</span></span><br><span class="line">    <span class="comment">// call(this,值1,值2....) apply(this, [值1, 值2...]) bind(this, 值1, 值2....)</span></span><br><span class="line">    <span class="comment">// 从表面上看bind方法和call方法完全一致，但是</span></span><br><span class="line">    <span class="comment">// bind方法可以再调用之后不执行函数，而call和apply只要调用就立刻执行</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">100</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">user</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好&#x27;</span>, user);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">// window.a</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让fn1的this指向obj 使用call方法，只要运行代码，程序就会立刻执行</span></span><br><span class="line">    <span class="comment">// fn1.call(obj, &#x27;张三&#x27;);</span></span><br><span class="line">    <span class="comment">// fn1.apply(obj, [&#x27;张三&#x27;]);</span></span><br><span class="line">    <span class="comment">// 我的需要: fn1作为btn的事件处理函数，点击按钮之后再执行</span></span><br><span class="line">    <span class="comment">// fn1需要改变this指向，同时需要向fn1中传值</span></span><br><span class="line">    btn.<span class="property">onclick</span> = fn1.<span class="title function_">bind</span>(obj, <span class="string">&#x27;张三&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src= "/hexo/loading" data-lazy-src="/hexo/%E5%AD%A6%E4%B9%A0/mdimages/image-20211223194857541.png" alt="image-20211223194857541"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="comment">//this == obj</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line">ver person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;deng&#x27;</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(obj,<span class="string">&#x27;cheng&#x27;</span>,<span class="number">300</span>)</span><br><span class="line"><span class="comment">//test  ---&gt; test.call()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认函数运行，相当于隐式运行.call( )</span></span><br><span class="line"><span class="comment">//把Person时传入obj，相当于this == obj this.name = name ,,this.age = age</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="comment">//this == obj</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="12-reduce"><a href="#12-reduce" class="headerlink" title="12.reduce"></a>12.reduce</h4><p><code>**reduce()**</code> 方法对数组中的每个元素执行一个由您提供的<strong>reducer</strong>函数(升序执行)，将其结果汇总为单个返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">previousValue, currentValue</span>) =&gt; previousValue + currentValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1.<span class="title function_">reduce</span>(reducer));</span><br><span class="line"><span class="comment">//reduce 里面为一个回调函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>.<span class="title function_ invoke__">reduce</span>(<span class="function"><span class="keyword">function</span>(<span class="params">prev, current, currentIndex, arr</span>), <span class="title">initialValue</span>)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>prev：函数传进来的初始值或上一次回调的返回值</li>
<li>current：数组中当前处理的元素值</li>
<li>currentIndex：当前元素索引</li>
<li>arr：当前元素所属的数组本身</li>
<li>initialValue：传给函数的初始值</li>
</ol>
<h4 id="13-Map"><a href="#13-Map" class="headerlink" title="13.Map"></a>13.Map</h4><p><strong>加工数据</strong></p>
<p><code>**map()**</code> 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass a function to map</span></span><br><span class="line"><span class="keyword">const</span> map1 = array1.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1);</span><br><span class="line"><span class="comment">// expected output: Array [2, 8, 18, 32]</span></span><br></pre></td></tr></table></figure>

<h4 id="14-splice"><a href="#14-splice" class="headerlink" title="14.splice"></a>14.splice</h4><ul>
<li><p>删除 修改 清空</p>
</li>
<li><pre><code class="js">//splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const months = [&#x27;Jan&#x27;, &#x27;March&#x27;, &#x27;April&#x27;, &#x27;June&#x27;];</span><br><span class="line">  months.splice(1, 0, &#x27;Feb&#x27;);</span><br><span class="line">  // inserts at index 1</span><br><span class="line">  console.log(months);</span><br><span class="line">  // expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;June&quot;]</span><br><span class="line">  </span><br><span class="line">  months.splice(4, 1, &#x27;May&#x27;);</span><br><span class="line">  // replaces 1 element at index 4</span><br><span class="line">  console.log(months);</span><br><span class="line">  </span><br><span class="line">  //1.要修改的元素索引</span><br><span class="line">  //2.要删除的元素个数</span><br><span class="line">  //3.要添加的元素</span><br><span class="line">  </span><br><span class="line">  //清空 arr.splice(0,arr.length)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ul>
<h4 id="15-URI-和-URL"><a href="#15-URI-和-URL" class="headerlink" title="15.URI 和 URL"></a>15.URI 和 URL</h4><h5 id="一-统一资源标识符（URI）"><a href="#一-统一资源标识符（URI）" class="headerlink" title="一.统一资源标识符（URI）"></a>一.统一资源标识符（URI）</h5><p>&lt;1&gt;什么是URI</p>
<p>URI，统一资源标志符(Uniform Resource Identifier， URI)，表示的是web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个URI进行标识的。</p>
<p>&lt;2&gt;URI的结构组成</p>
<p>URI通常由三部分组成：</p>
<p>①资源的命名机制；</p>
<p>②存放资源的主机名；</p>
<p>③资源自身的名称。</p>
<p>（注意：这只是一般URI资源的命名方式，只要是可以唯一标识资源的都被称为URI，上面三条合在一起是URI的充分不必要条件）</p>
<p>&lt;3&gt;URI举例</p>
<p>如：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32595453/article/details/79516787">https://blog.csdn.net/qq_32595453/article/details/79516787</a></p>
<p>我们可以这样解释它：</p>
<p>①这是一个可以通过https协议访问的资源，</p>
<p>②位于主机 blog.csdn.net上，</p>
<p>③通过“&#x2F;qq_32595453&#x2F;article&#x2F;details&#x2F;79516787”可以对该资源进行唯一标识（注意，这个不一定是完整的路径）</p>
<p>注意：以上三点只不过是对实例的解释，以上三点并不是URI的必要条件，URI只是一种概念，怎样实现无所谓，只要它唯一标识一个资源就可以了。</p>
<h5 id="二、URL"><a href="#二、URL" class="headerlink" title="二、URL"></a>二、URL</h5><p>URL是URI的一个子集。它是Uniform Resource Locator的缩写，译为“统一资源定位 符”。</p>
<p>通俗地说，URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。</p>
<p>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式。</p>
<p>URL的一般格式为(带方括号[]的为可选项)：</p>
<p>protocol :&#x2F;&#x2F; hostname[:port] &#x2F; path &#x2F; [;parameters][?query]#fragment</p>
<p>URL的格式由三部分组成： </p>
<p>①第一部分是协议(或称为服务方式)。</p>
<p>②第二部分是存有该资源的主机IP地址(有时也包括端口号)。</p>
<p>③第三部分是主机资源的具体地址，如目录和文件名等。</p>
<p>第一部分和第二部分用“:&#x2F;&#x2F;”符号隔开，</p>
<p>第二部分和第三部分用“&#x2F;”符号隔开。</p>
<p>第一部分和第二部分是不可缺少的，第三部分有时可以省略。</p>
<h5 id="三、URI和URL之间的区别"><a href="#三、URI和URL之间的区别" class="headerlink" title="三、URI和URL之间的区别"></a>三、URI和URL之间的区别</h5><p>从上面的例子来看，你可能觉得URI和URL可能是相同的概念，其实并不是，URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。</p>
<h5 id="1-decodeURI"><a href="#1-decodeURI" class="headerlink" title="1.decodeURI( )"></a>1.decodeURI( )</h5><p><code>**decodeURI()**</code> 函数能解码由<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI"><code>encodeURI</code></a> 创建或其它流程得到的统一资源标识符（URI）。</p>
<h5 id="2-encodeURI"><a href="#2-encodeURI" class="headerlink" title="2.encodeURI( )"></a>2.encodeURI( )</h5><p><code>**encodeURI()**</code> 函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 (该字符的 UTF-8 编码仅为四转义序列)由两个 “代理” 字符组成)。</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><h4 id="1-Object-defineProperty"><a href="#1-Object-defineProperty" class="headerlink" title="1.Object.defineProperty()"></a>1.Object.defineProperty()</h4><p><code>**Object.defineProperty()**</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(object1, <span class="string">&#x27;property1&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">object1.<span class="property">property1</span> = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// throws an error in strict mode</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object1.<span class="property">property1</span>);</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th><code>configurable</code></th>
<th><code>enumerable</code></th>
<th><code>value</code></th>
<th><code>writable</code></th>
<th><code>get</code></th>
<th><code>set</code></th>
</tr>
</thead>
<tbody><tr>
<td>数据描述符</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
</tr>
<tr>
<td>存取描述符</td>
<td>可以</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
<td>可以</td>
<td>可以</td>
</tr>
</tbody></table>
<ul>
<li><p><code>configurable</code></p>
<p>当且仅当该属性的 <code>configurable</code> 键值为 <code>true</code> 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。 <strong>默认为</strong> **<code>false</code>**。</p>
</li>
<li><p><code>enumerable</code></p>
<p>当且仅当该属性的 <code>enumerable</code> 键值为 <code>true</code> 时，该属性才会出现在对象的枚举属性中。 **默认为 <code>false</code>**。</p>
</li>
</ul>
<p>数据描述符还具有以下可选键值：</p>
<ul>
<li><p><code>value</code></p>
<p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。 **默认为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>**。</p>
</li>
<li><p><code>writable</code></p>
<p>当且仅当该属性的 <code>writable</code> 键值为 <code>true</code> 时，属性的值，也就是上面的 <code>value</code>，才能被<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#assignment_operators"><code>赋值运算符</code> (en-US)</a>改变。 <strong>默认为 <code>false</code>。</strong></p>
</li>
</ul>
<p>存取描述符还具有以下可选键值：</p>
<ul>
<li><p><code>get</code></p>
<p>属性的 getter 函数，如果没有 getter，则为 <code>undefined</code>。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 <code>this</code> 对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。 **默认为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>**。</p>
</li>
<li><p><code>set</code></p>
<p>属性的 setter 函数，如果没有 setter，则为 <code>undefined</code>。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 <code>this</code> 对象。 **默认为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>**。</p>
</li>
</ul>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error#error_types">Error 类型</a></p>
<p>除了通用的Error构造函数外，JavaScript还有6个其他类型的错误构造函数。更多客户端异常,详见 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/JavaScript/Guide/Statements#exception_handling_statements">Exception Handling Statements</a>。</p>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/EvalError"><code>EvalError</code></a></strong></p>
<p>创建一个error实例，表示错误的原因：与 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval"><code>eval()</code></a> 有关。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/InternalError"><code>InternalError</code></a></strong> </p>
<p>创建一个代表Javascript引擎内部错误的异常抛出的实例。 如: “递归太多”.</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RangeError"><code>RangeError</code></a></strong></p>
<p>创建一个error实例，表示错误的原因：数值变量或参数超出其有效范围。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError"><code>ReferenceError</code></a></strong></p>
<p>创建一个error实例，表示错误的原因：无效引用。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError"><code>SyntaxError</code></a></strong></p>
<p>创建一个error实例，表示错误的原因：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval"><code>eval()</code></a>在解析代码的过程中发生的语法错误。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a></strong></p>
<p>创建一个error实例，表示错误的原因：变量或参数不属于有效类型。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/URIError"><code>URIError</code></a></strong></p>
<p>创建一个error实例，表示错误的原因：给 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI"><code>encodeURI()</code></a>或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURI"><code>decodeURI()</code></a>传递的参数无效。</p>
</li>
</ul>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">//得到data为 ...</span></span><br><span class="line"><span class="comment">//data = xxxxxxx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将data放入new Date(  ..) 可以得到曾经保存的时间</span></span><br><span class="line"><span class="keyword">const</span> data1 = <span class="keyword">new</span> <span class="title class_">Date</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以根据时间戳的差值计算出时间间隔</span></span><br></pre></td></tr></table></figure>





<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><p>背景：js诞生之际是一门单线程语言，功能较少。后随着计算机的发展，ajax等的兴起。当计算机执行一个需要较长时间的进程时候，为了提高计算机效率，不让其空闲，就有了异步。</p>
<h4 id="什么是异步js"><a href="#什么是异步js" class="headerlink" title="什么是异步js"></a>什么是异步js</h4><ul>
<li>​    在js中，任务分为两种，同步任务和异步任务。同步任务在主线程中，一开始就执行，而异步任务在需要时或者特点条件下才会执行。    <ul>
<li><p>异步js主要有：</p>
<ol>
<li>DOM操作</li>
<li>定时器</li>
<li>AJAX请求</li>
</ol>
</li>
<li><p>在程序执行过程中，所以的同步任务都会在主线程上执行，形成一个执行栈</p>
</li>
<li><p>主线程之外还存在一个任务队列，只要异步任务有了结果，就会在任务队列中放置一个事件，当同步任务执行完，或者说执行栈一被清空。主线程就开始执行任务队列里面的异步事件，即当前异步事件的回调函数。再任务队列中，事件遵循先进后出规则。</p>
</li>
</ul>
</li>
</ul>
<h4 id="异步事件注意点"><a href="#异步事件注意点" class="headerlink" title="异步事件注意点"></a>异步事件注意点</h4><ul>
<li>异步事件的发生先后顺序是不确定的，这取决于当前事件在子进程中完成的先后顺序，先完成的先进入任务队列，先执行。</li>
<li>定时器由于任务队列的先进后出，可能会延时发生。当定时器时间到达时，才会在任务队列中添加事件（在这之前，挂载在子进程上），而此时定时器需要等到先排队的事件执行完才能执行。（前提是执行栈也已经被清空）</li>
<li>Event loop 主线程在任务队列中执行事件是循环不断的，整个这个的运行机制叫做Event loop。</li>
<li>html5 规定定时器最短时间间隔为4ms，足的会变为4ms。老版本的规定为10ms，DOM时间触发后不会立即执行，会延误16ms。</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li><p>Promise是异步编程的一种解决方案。比传统的解决方案 ——回调函数和事件——更合理强大。</p>
</li>
<li><p>可以说是一个容器，里面保存着某个未来才会结束的事件，（通常是一个异步操作）的结果。可以获取异步操作的消息</p>
</li>
<li><p>特点</p>
<ul>
<li><p>对象的状态不受外界影响，~代表一个异步操作，有三种状态</p>
<ul>
<li>pending</li>
<li>fulfilled</li>
<li>rejected</li>
</ul>
<p>只有异步的操作结果，可以决定当前是哪一种状态，任何其他的操作都无法改变这个状态。</p>
</li>
<li><p>一旦状态改变就不会再变，只有两种可能</p>
<ul>
<li>pending -&gt; fulfilled</li>
<li>pending -&gt; rejected</li>
</ul>
<p>只要是事件发生了，就不会再改变，叫做定型resolved。</p>
<p>而事件的特点是，如果你错过了他，再去监听，是得不到结果的。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化Promise对象</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>() <span class="title function_">resolve</span>(info);</span><br><span class="line">                    <span class="keyword">else</span> <span class="title function_">reject</span>(err);</span><br><span class="line">                    &#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">info</span>) =&gt;</span> &#123;&#125; , (err) =&#123;&#125; )</span><br><span class="line"></span><br><span class="line">.<span class="title function_">catch</span>((err)=&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果后面嵌套then。里面返回promise对象</li>
<li><strong>.then 可以链式不断调用</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>() <span class="title function_">resolve</span>(info);</span><br><span class="line">                    <span class="keyword">else</span> <span class="title function_">reject</span>(err);</span><br><span class="line">                    &#125;)</span><br><span class="line">&#125; , (err) =&#123;&#125; )</span><br><span class="line"></span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>() <span class="title function_">resolve</span>(info);</span><br><span class="line">                    <span class="keyword">else</span> <span class="title function_">reject</span>(err);</span><br><span class="line">                    &#125;)</span><br><span class="line">&#125;, (err) =&#123;&#125;)</span><br><span class="line"></span><br><span class="line">.<span class="property">then</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//.catch 每一个状态为reject都会执行catch()</span></span><br></pre></td></tr></table></figure>

<h5 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h5><ul>
<li>用await替代then，<strong>await</strong>和<strong>async</strong>需要配合使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">move</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> p1 = <span class="keyword">await</span> <span class="title function_">ajax</span>(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;./a.json&#x27;</span>)</span><br><span class="line">            <span class="comment">// console.log(p1)</span></span><br><span class="line">            <span class="keyword">const</span> data1 = p1.<span class="property">src</span></span><br><span class="line">            <span class="comment">// console.log(data1)</span></span><br><span class="line">            <span class="keyword">const</span> p2 = <span class="keyword">await</span> <span class="title function_">ajax</span>(<span class="string">&#x27;get&#x27;</span>,data1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> data2 = p2.<span class="property">src</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> p3 = <span class="keyword">await</span> <span class="title function_">ajax</span>(<span class="string">&#x27;get&#x27;</span>,data2)</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(p3.<span class="property">msg</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">move</span>()</span><br></pre></td></tr></table></figure>

<p>async 和 await 执行顺序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>) <span class="comment">//执行3</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()              <span class="comment">//执行函数 4</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)   <span class="comment">//挂载等待1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>) <span class="comment">//执行5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)   <span class="comment">//顺序执行1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)  <span class="comment">//等待微任务1</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="title function_">async1</span>();   <span class="comment">//执行函数 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>) <span class="comment">//立即执行 6 </span></span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;       <span class="comment">//挂载等待2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)   <span class="comment">//立即执行7</span></span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br><span class="line">知识点</span><br><span class="line">显然，这考察的是js中的事件循环和回调队列。注意以下几点：</span><br><span class="line">     *   <span class="title class_">Promise</span>优先于<span class="built_in">setTimeout</span>宏任务。所以，<span class="built_in">setTimeout</span>回调会在最后执行。</span><br><span class="line">     *   <span class="title class_">Promise</span>一旦被定义，就会立即执行。</span><br><span class="line">     *   <span class="title class_">Promise</span>的reject和resolve是异步执行的回调。所以，<span class="title function_">resolve</span>()会被放到回调队列中，在主函数执行完和<span class="built_in">setTimeout</span>前调用。</span><br><span class="line">     *   <span class="keyword">await</span>执行完后，会让出线程。<span class="keyword">async</span>标记的函数会返回一个<span class="title class_">Promise</span>对象</span><br><span class="line"><span class="keyword">await</span>后面的语句会在<span class="keyword">await</span>执行完之后再执行。定时器为宏任务，会在微任务执行完之后再执行。</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">queryData</span>(<span class="params"></span>) &#123;</span><br><span class="line">      # <span class="number">2.1</span>  添加<span class="keyword">await</span>之后 当前的<span class="keyword">await</span> 返回结果之后才会执行后面的代码   </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">var</span> info = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;async1&#x27;</span>);</span><br><span class="line">      #<span class="number">2.2</span>  让异步代码看起来、表现起来更像同步代码</span><br><span class="line">      <span class="keyword">var</span> ret = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;async2?info=&#x27;</span> + info.<span class="property">data</span>);</span><br><span class="line">      <span class="keyword">return</span> ret.<span class="property">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>

<h5 id="ajax-配合async"><a href="#ajax-配合async" class="headerlink" title="ajax 配合async"></a>ajax 配合async</h5><h5 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h5><p>用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p>
<p>不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，<strong>此时第一个被<code>reject</code>的实例的返回值</strong>，会传递给<code>p</code>的回调函数。</p>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那<strong>个率先改变的 Promise 实例的返回值，</strong>就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<p><strong><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束</strong></p>
<h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><p>在异步任务中，将任务分为两种，分别是：</p>
<ul>
<li><pre><code>             宏任务
</code></pre>
<ul>
<li>定时器</li>
<li>requestAnimationFrame</li>
</ul>
</li>
<li><p>​                  微任务</p>
<ul>
<li>promise</li>
</ul>
</li>
<li><p>在任务队列之外，将宏任务和微任务分别挂载在宏任务队列和微任务。当同步任务执行完之后，会进行Event loop 执行任务队列。</p>
<ul>
<li><p>执行顺序是：</p>
<ul>
<li>先执行同步任务，再执行异步任务</li>
<li>先执行微任务，再执行宏任务</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); <span class="comment">//同步执行1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="number">4</span>); <span class="comment">//宏任务1  定时器1</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);	<span class="comment">//同步执行2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);  <span class="comment">//微任务1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123; <span class="comment">//宏任务2 定时器2</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当执行promise内的代码时，语句遵循同步执行的规则</span></span><br><span class="line"><span class="comment">//此处有一个简写 _ =&gt; 表示舍弃参数，不进行传值操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>requestAnimationFrame    请求动画帧</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>60HZ 当你什么都不做的时候，电脑也会以每秒60次的刷新速率更新，</p>
</li>
<li><p>动画原理</p>
<ul>
<li>而动画的本质就是人眼看到图像被属性变化而引起的视觉效果，这个效果要以平滑连贯的方式进行过渡</li>
</ul>
</li>
<li><p>setTimeout ( 存在丢帧现象 )</p>
<ul>
<li>setTimeout的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 <strong>setTimeout 的实际执行时间一般要比其设定的时间晚一些。</strong></li>
<li>刷新频率受<strong>屏幕分辨率</strong>和<strong>屏幕尺寸</strong>的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</li>
</ul>
</li>
<li><h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h4><ul>
<li><p>requestAnimationFrame最大的优势是<strong>由系统来决定回调函数的执行时机</strong></p>
<ul>
<li><p>具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000&#x2F;75&#x3D;13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。<strong>它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次</strong>，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p>
</li>
<li><p>&#96;&#96;&#96;js<br>    let box &#x3D; document.querySelector(‘.box’);<br>    let len &#x3D; 0;<br>    function fn() {<br>        len +&#x3D; 5;<br>        box.style.left &#x3D; len + ‘px’;<br>        if (len &lt; 1280) {<br>            window.requestAnimationFrame(fn);<br>        }<br>    }<br>    window.requestAnimationFrame(fn);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      （1）requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回 流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。 </span><br><span class="line"></span><br><span class="line">      （2）在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然 就意味着更少的 CPU、GPU 和内存使用量 </span><br><span class="line"></span><br><span class="line">      （3）requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动 优化方法的调用，**并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销**</span><br><span class="line"></span><br><span class="line">### ES6</span><br><span class="line"></span><br><span class="line">#### 箭头函数</span><br><span class="line"></span><br><span class="line">​	本质是一个语法糖</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">() =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">//1.如果箭头函数只有一个参数，则括号可以省略</span><br><span class="line">item =&gt; &#123;&#125;   //形如</span><br><span class="line">//2如果函数体只有一条语句，则可以省略&#123;&#125;括号</span><br><span class="line">() =&gt; return &#x27;hello&#x27;</span><br><span class="line"></span><br><span class="line">(a, b) =&gt; a + b</span><br><span class="line"></span><br><span class="line">(a) =&gt; &#123;</span><br><span class="line">  a = a + 1</span><br><span class="line">  return a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</span><br><span class="line">// SyntaxError:</span><br><span class="line">x =&gt; &#123; foo: x &#125;</span><br><span class="line">//因为和函数体的&#123; ... &#125;有语法冲突，所以要改为：</span><br><span class="line"></span><br><span class="line">// ok:</span><br><span class="line">x =&gt; (&#123; foo: x &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>(1). 箭头函数this为父作用域的this，不是调用时的this<br>箭头函数的this永远指向其父作用域，任何方法都改变不了，包括call，apply，bind。<br>普通函数的this指向调用它的那个对象。</p>
<p>(2). 箭头函数不能作为构造函数，不能使用new</p>
<p>(3). 箭头函数没有arguments，caller，callee</p>
<p>箭头函数本身没有arguments，如果箭头函数在一个function内部，它会将外部函数的arguments拿过来使用。</p>
<p>箭头函数中要想接收不定参数，应该使用rest参数…解决。</p>
<p> (4). 箭头函数通过call和apply调用，不会改变this指向，只会传入参数</p>
<p>(5). 箭头函数没有原型属性</p>
<p>(6). 箭头函数不能作为Generator函数，不能使用yield关键字</p>
<p>(7). 箭头函数返回对象时，要加一个小括号</p>
<p>(8). 箭头函数在ES6 class中声明的方法为实例方法，不是原型方法</p>
<p>(9). 多重箭头函数就是一个高阶函数，相当于内嵌函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>). 箭头函数常见错误</span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">foo</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">bar</span>()  <span class="comment">//undefined</span></span><br><span class="line">bar函数中的<span class="variable language_">this</span>指向父作用域，而a对象没有作用域，因此<span class="variable language_">this</span>不是a，打印结果为<span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bar</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">foo</span>)</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>()</span><br><span class="line">a.<span class="title function_">bar</span>()  <span class="comment">//undefined</span></span><br><span class="line">原型上使用箭头函数，<span class="variable language_">this</span>指向是其父作用域，并不是对象a，因此得不到预期结果</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>一些<span class="variable language_">this</span>的指向实例</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">  <span class="attr">getAge</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="variable language_">this</span>.<span class="property">birth</span>); <span class="comment">//this指向obj对象</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">getAge</span>(); <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// this指向window或undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getAge</span>();<span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// this指向obj对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getAge</span>(); <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">       <span class="attr">getAge</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getAge</span>(); <span class="comment">//window</span></span><br><span class="line">作为对象的属性时，<span class="variable language_">this</span>的指向则不再是对象本身了，箭头函数捕获的是obj&#123;&#125;这个对象的环境，然后这个环境的<span class="variable language_">this</span>指向的是<span class="variable language_">window</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">CodeFish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://codefish.cc/2021/12/11/javascript%E5%85%A5%E9%97%A8/">https://codefish.cc/2021/12/11/javascript%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/hexo/tags/javaScript/">javaScript</a></div><div class="post_share"><div class="social-share" data-image="/hexo/img/2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/hexo/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "/hexo/loading" data-lazy-src="/hexo/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/hexo/img/apay.jpg" target="_blank"><img class="post-qr-code-img" src= "/hexo/loading" data-lazy-src="/hexo/img/apay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/hexo/2021/12/20/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"><img class="prev-cover" src= "/hexo/loading" data-lazy-src="/hexo/img/9.jpg" onerror="onerror=null;src='/hexo/img/favicon.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Vue 父组件——子组件通信</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/hexo/loading" data-lazy-src="/hexo/img/avatar.jpg" onerror="this.onerror=null;this.src='/hexo/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CodeFish</div><div class="author-info__description">这是codefish的个人博客,一个前端小菜鸟，欢迎指正交流，部分来源于网络，如有侵权请告知删除</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/hexo/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a></div><div class="card-info-data-item"><a href="/hexo/tags/"><div class="headline">Tags</div><div class="length-num">38</div></a></div><div class="card-info-data-item"><a href="/hexo/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/codefishzhou"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/codefishzhou" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2358514288&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#javascript%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">javascript介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E6%98%AF%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BD%9C%E4%B8%BAweb%E7%9A%84"><span class="toc-number">1.1.</span> <span class="toc-text">JavaScript 是脚本语言（作为web的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">JavaScript作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.</span> <span class="toc-text">宿主环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-%E7%9A%84%E5%87%86%E5%A4%87%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">JS 的准备语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">文档入口函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">如果页面有多个入口函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onclick%E5%90%8C%E7%90%86"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">onclick同理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E6%98%AF%E4%B8%80%E9%97%A8%E5%BC%B1%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">js是一门弱类型语言</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.7.</span> <span class="toc-text">String字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">字符串拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2-%E2%80%93-%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">创建字符串   –   通过构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97"><span class="toc-number">1.8.</span> <span class="toc-text">数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94-boolean"><span class="toc-number">1.9.</span> <span class="toc-text">布尔 boolean</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9C%9F%E5%92%8C%E5%81%87-false-%E5%92%8Ctrue"><span class="toc-number">1.9.0.0.1.</span> <span class="toc-text">真和假 false 和true</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-number">1.10.</span> <span class="toc-text">null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Underfinded"><span class="toc-number">1.11.</span> <span class="toc-text">Underfinded</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.12.</span> <span class="toc-text">基础数据类型之间的类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.12.0.1.</span> <span class="toc-text">强制数据类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.12.0.2.</span> <span class="toc-text">自动类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97"><span class="toc-number">1.12.1.</span> <span class="toc-text">计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E6%95%B0%E4%B8%8D%E8%83%BD%E4%B8%BA0-infinity"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">除数不能为0 infinity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E6%93%8D%E4%BD%9Chtml%E5%92%8Ccss%E4%BF%AE%E6%94%B9%E6%A0%87%E7%AD%BE%E6%A0%B7%E5%BC%8F%E3%80%81"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">JS操作html和css修改标签样式、</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.12.2.</span> <span class="toc-text">常用运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.12.3.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86"><span class="toc-number">1.12.4.</span> <span class="toc-text">栈和堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E4%B8%A5%E6%A0%BC%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-number">1.12.5.</span> <span class="toc-text">JS 严格区分大小写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Null"><span class="toc-number">1.12.6.</span> <span class="toc-text">Null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Underfinded-1"><span class="toc-number">1.12.7.</span> <span class="toc-text">Underfinded</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.13.</span> <span class="toc-text">流程控制和循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#swith"><span class="toc-number">1.13.0.1.</span> <span class="toc-text">swith</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E5%B1%95%E7%A4%BA%E7%BB%93%E6%9E%9C%E4%B8%8D%E7%A1%AE%E5%AE%9A%EF%BC%8Cswitch%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="toc-number">1.13.0.2.</span> <span class="toc-text">switch展示结果不确定，switch保存数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.13.1.</span> <span class="toc-text">循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.14.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-if%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.14.1.</span> <span class="toc-text">1.if分支语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-if-else%E5%8F%8C%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.14.2.</span> <span class="toc-text">2.if else双分支语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-if-else-if%E5%A4%9A%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.14.3.</span> <span class="toc-text">3.if else if多分支语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.14.4.</span> <span class="toc-text">4.三元表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.14.5.</span> <span class="toc-text">5.switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-switch%E8%AF%AD%E5%8F%A5%E5%92%8Cif-else-if%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.6.</span> <span class="toc-text">6.switch语句和if else if语句的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.15.</span> <span class="toc-text">循环流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.15.1.</span> <span class="toc-text">1.for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.15.2.</span> <span class="toc-text">2.while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-do-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.15.3.</span> <span class="toc-text">3.do while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.15.4.</span> <span class="toc-text">4.小结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#do-while-%E8%87%B3%E5%B0%91%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%EF%BC%8Cwhile%EF%BC%8Cfor%E6%9C%80%E5%B0%91%E6%89%A7%E8%A1%8C0%E6%AC%A1"><span class="toc-number">1.15.4.0.1.</span> <span class="toc-text">do while 至少执行一次，while，for最少执行0次</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-continue%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.15.4.1.</span> <span class="toc-text">1.continue关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-break%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.15.4.2.</span> <span class="toc-text">2.break关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%A6className-x3D-%E2%80%98%E2%80%99-%E5%8E%BB%E6%8E%89%E7%B1%BB%E5%90%8D"><span class="toc-number">1.15.5.</span> <span class="toc-text">…className &#x3D; ‘’ 去掉类名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.15.6.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.15.6.1.</span> <span class="toc-text">使用情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E4%BD%8D"><span class="toc-number">1.15.7.</span> <span class="toc-text">空位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">1.15.7.1.</span> <span class="toc-text">数组的增删改查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api-%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-number">1.16.</span> <span class="toc-text">api (接口方法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.17.</span> <span class="toc-text">数组方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.18.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%EF%BC%88object%EF%BC%89"><span class="toc-number">1.18.1.</span> <span class="toc-text">对象（object）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8C%85%E5%90%AB%E4%B8%A4%E7%A7%8D-%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.18.1.1.</span> <span class="toc-text">对象包含两种 属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.18.1.2.</span> <span class="toc-text">创建对象的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0"><span class="toc-number">1.18.2.</span> <span class="toc-text">闭包函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-number">1.18.3.</span> <span class="toc-text">字符串方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-number">1.18.3.1.</span> <span class="toc-text">1. 获取字符串长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%80%BC"><span class="toc-number">1.18.3.2.</span> <span class="toc-text">2. 获取字符串指定位置的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89charAt"><span class="toc-number">1.18.3.3.</span> <span class="toc-text">（1）charAt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89charCodeAt"><span class="toc-number">1.18.3.4.</span> <span class="toc-text">（2）charCodeAt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A3%80%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E5%BA%8F%E5%88%97"><span class="toc-number">1.18.3.5.</span> <span class="toc-text">3. 检索字符串是否包含特定序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89indexOf"><span class="toc-number">1.18.3.6.</span> <span class="toc-text">（1）indexOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89lastIndexOf"><span class="toc-number">1.18.3.7.</span> <span class="toc-text">（2）lastIndexOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89includes"><span class="toc-number">1.18.3.8.</span> <span class="toc-text">（3）includes()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89startsWith"><span class="toc-number">1.18.3.9.</span> <span class="toc-text">（4）startsWith()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89endsWith"><span class="toc-number">1.18.3.10.</span> <span class="toc-text">（5）endsWith()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.18.3.11.</span> <span class="toc-text">4. 连接多个字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E6%88%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.18.3.12.</span> <span class="toc-text">5. 字符串分割成数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.18.3.13.</span> <span class="toc-text">6. 截取字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-slice"><span class="toc-number">1.18.3.14.</span> <span class="toc-text">（1） slice()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-substr"><span class="toc-number">1.18.3.15.</span> <span class="toc-text">（2） substr()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89-substring"><span class="toc-number">1.18.3.16.</span> <span class="toc-text">（3） substring()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.18.3.17.</span> <span class="toc-text">7. 字符串大小写转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89toLowerCase"><span class="toc-number">1.18.3.18.</span> <span class="toc-text">（1）toLowerCase()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89toUpperCase"><span class="toc-number">1.18.3.19.</span> <span class="toc-text">（2）toUpperCase()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">1.18.3.20.</span> <span class="toc-text">8. 字符串模式匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89replace"><span class="toc-number">1.18.3.21.</span> <span class="toc-text">（1）replace()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89match"><span class="toc-number">1.18.3.22.</span> <span class="toc-text">（2）match()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89search"><span class="toc-number">1.18.3.23.</span> <span class="toc-text">（3）search()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E7%A7%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%94%B6%E5%B0%BE%E7%A9%BA%E7%99%BD%E7%AC%A6"><span class="toc-number">1.18.3.24.</span> <span class="toc-text">9. 移除字符串收尾空白符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89trim"><span class="toc-number">1.18.3.25.</span> <span class="toc-text">（1）trim()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89trimStart"><span class="toc-number">1.18.3.26.</span> <span class="toc-text">（2）trimStart()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89trimEnd"><span class="toc-number">1.18.3.27.</span> <span class="toc-text">（3）trimEnd()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%AC%E8%BA%AB"><span class="toc-number">1.18.3.28.</span> <span class="toc-text">10. 获取字符串本身</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89valueOf"><span class="toc-number">1.18.3.29.</span> <span class="toc-text">（1）valueOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89toString"><span class="toc-number">1.18.3.30.</span> <span class="toc-text">（2）toString()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E9%87%8D%E5%A4%8D%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.18.3.31.</span> <span class="toc-text">11. 重复一个字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E8%A1%A5%E9%BD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-number">1.18.3.32.</span> <span class="toc-text">12. 补齐字符串长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89padStart"><span class="toc-number">1.18.3.33.</span> <span class="toc-text">（1）padStart()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89padEnd"><span class="toc-number">1.18.3.34.</span> <span class="toc-text">（2）padEnd()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B8%BA%E6%95%B0%E5%AD%97"><span class="toc-number">1.18.3.35.</span> <span class="toc-text">13. 字符串转为数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89parseInt"><span class="toc-number">1.18.3.36.</span> <span class="toc-text">（1）parseInt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89parseFloat"><span class="toc-number">1.18.3.37.</span> <span class="toc-text">（2）parseFloat()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.18.4.</span> <span class="toc-text">数组方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B5%8B%E8%AF%95%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0"><span class="toc-number">1.18.4.1.</span> <span class="toc-text">1.测试所有元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#every%EF%BC%88%EF%BC%89"><span class="toc-number">1.18.4.2.</span> <span class="toc-text">every（）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A1%AB%E5%85%85%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BB%8E%E8%B5%B7%E5%A7%8B%E7%B4%A2%E5%BC%95%E5%88%B0%E7%BB%88%E6%AD%A2%E7%B4%A2%E5%BC%95%E5%86%85%E7%9A%84%E5%85%A8%E9%83%A8%E5%85%83%E7%B4%A0%E3%80%82-fill"><span class="toc-number">1.18.4.3.</span> <span class="toc-text">2.填充一个数组中从起始索引到终止索引内的全部元素。(fill)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fill"><span class="toc-number">1.18.4.4.</span> <span class="toc-text">fill()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E3%80%82"><span class="toc-number">1.18.4.5.</span> <span class="toc-text">3.合并两个或多个数组。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#concat-%E6%96%B9%E6%B3%95"><span class="toc-number">1.18.4.6.</span> <span class="toc-text">**concat()** 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.18.5.</span> <span class="toc-text">5.遍历数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.18.5.1.</span> <span class="toc-text">6.数组去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniqWith-js%E5%BA%93"><span class="toc-number">1.18.5.2.</span> <span class="toc-text">_.uniqWith()     js库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">1.18.5.3.</span> <span class="toc-text">7.查找元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1"><span class="toc-number">1.18.5.4.</span> <span class="toc-text">8.回调地狱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-eval"><span class="toc-number">1.18.5.5.</span> <span class="toc-text">9.eval</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-copyWithin"><span class="toc-number">1.18.5.6.</span> <span class="toc-text">10.copyWithin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-reduce"><span class="toc-number">1.18.5.7.</span> <span class="toc-text">12.reduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-Map"><span class="toc-number">1.18.5.8.</span> <span class="toc-text">13.Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-splice"><span class="toc-number">1.18.5.9.</span> <span class="toc-text">14.splice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-URI-%E5%92%8C-URL"><span class="toc-number">1.18.5.10.</span> <span class="toc-text">15.URI 和 URL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88URI%EF%BC%89"><span class="toc-number">1.18.5.10.1.</span> <span class="toc-text">一.统一资源标识符（URI）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81URL"><span class="toc-number">1.18.5.10.2.</span> <span class="toc-text">二、URL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81URI%E5%92%8CURL%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.5.10.3.</span> <span class="toc-text">三、URI和URL之间的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-decodeURI"><span class="toc-number">1.18.5.10.4.</span> <span class="toc-text">1.decodeURI( )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-encodeURI"><span class="toc-number">1.18.5.10.5.</span> <span class="toc-text">2.encodeURI( )</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-1"><span class="toc-number">1.18.5.11.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.18.6.</span> <span class="toc-text">对象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Object-defineProperty"><span class="toc-number">1.18.6.1.</span> <span class="toc-text">1.Object.defineProperty()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error"><span class="toc-number">1.18.7.</span> <span class="toc-text">Error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-number">1.18.8.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">1.18.9.</span> <span class="toc-text">异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5js"><span class="toc-number">1.18.9.1.</span> <span class="toc-text">什么是异步js</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">1.18.9.2.</span> <span class="toc-text">异步事件注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-number">1.18.10.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#async-await"><span class="toc-number">1.18.10.0.1.</span> <span class="toc-text">async await</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ajax-%E9%85%8D%E5%90%88async"><span class="toc-number">1.18.10.0.2.</span> <span class="toc-text">ajax 配合async</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-finally"><span class="toc-number">1.18.10.0.3.</span> <span class="toc-text">Promise.prototype.finally()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-all"><span class="toc-number">1.18.10.0.4.</span> <span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-race"><span class="toc-number">1.18.10.0.5.</span> <span class="toc-text">Promise.race()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.18.10.1.</span> <span class="toc-text">宏任务和微任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#requestAnimationFrame"><span class="toc-number">1.18.10.2.</span> <span class="toc-text">requestAnimationFrame</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/hexo/2024/08/11/nuxt%E5%AE%9E%E8%B7%B5/" title="nuxt实践"><img src= "/hexo/loading" data-lazy-src="/hexo/img/13.jpg" onerror="this.onerror=null;this.src='/hexo/img/favicon.png'" alt="nuxt实践"/></a><div class="content"><a class="title" href="/hexo/2024/08/11/nuxt%E5%AE%9E%E8%B7%B5/" title="nuxt实践">nuxt实践</a><time datetime="2024-08-11T21:55:34.000Z" title="Created 2024-08-11 21:55:34">2024-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo/2024/06/07/%E5%BC%80%E5%8F%91%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95,%20%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/" title="开发代码调试, 问题定位, h5调试总结"><img src= "/hexo/loading" data-lazy-src="/hexo/img/13.jpg" onerror="this.onerror=null;this.src='/hexo/img/favicon.png'" alt="开发代码调试, 问题定位, h5调试总结"/></a><div class="content"><a class="title" href="/hexo/2024/06/07/%E5%BC%80%E5%8F%91%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95,%20%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/" title="开发代码调试, 问题定位, h5调试总结">开发代码调试, 问题定位, h5调试总结</a><time datetime="2024-06-07T20:20:34.000Z" title="Created 2024-06-07 20:20:34">2024-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo/2023/07/10/vue%20hooks%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%9F/" title="vue hooks使用有感"><img src= "/hexo/loading" data-lazy-src="/hexo/img/13.jpg" onerror="this.onerror=null;this.src='/hexo/img/favicon.png'" alt="vue hooks使用有感"/></a><div class="content"><a class="title" href="/hexo/2023/07/10/vue%20hooks%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%9F/" title="vue hooks使用有感">vue hooks使用有感</a><time datetime="2023-07-10T19:20:34.000Z" title="Created 2023-07-10 19:20:34">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo/2022/10/20/1.generate%20%E8%BF%AD%E4%BB%A3%E5%99%A8/" title="js内置对象map,set,generate,iterator"><img src= "/hexo/loading" data-lazy-src="/hexo/img/13.jpg" onerror="this.onerror=null;this.src='/hexo/img/favicon.png'" alt="js内置对象map,set,generate,iterator"/></a><div class="content"><a class="title" href="/hexo/2022/10/20/1.generate%20%E8%BF%AD%E4%BB%A3%E5%99%A8/" title="js内置对象map,set,generate,iterator">js内置对象map,set,generate,iterator</a><time datetime="2022-10-20T16:20:34.000Z" title="Created 2022-10-20 16:20:34">2022-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo/2022/08/10/react_first/" title="react"><img src= "/hexo/loading" data-lazy-src="/hexo/img/basketball.jpg" onerror="this.onerror=null;this.src='/hexo/img/favicon.png'" alt="react"/></a><div class="content"><a class="title" href="/hexo/2022/08/10/react_first/" title="react">react</a><time datetime="2022-08-10T22:08:07.000Z" title="Created 2022-08-10 22:08:07">2022-08-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By CodeFish</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">给你一根杠杆，你也能撬动地球</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/hexo/js/utils.js"></script><script src="/hexo/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'LevoZej8tF1UF1m9XiT9Uun0-gzGzoHsz',
      appKey: 'unVgxfqkm7OHbwzRaDJUM497',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="7911809559" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="自律,坚持,breathe" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>